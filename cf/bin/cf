#!/usr/bin/env perl
#
# Copyright 2003-2005 Martin Andrews
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# $Id$

# All that is absolutely required is perl5 and its standard modules - but
# the following optional modules provide extra features or performance:
#
# File::Chmod
# LWP
# Crypt::SSLeay or IO::Socket::SSL
# Digest::MD5
# String::CRC::Cksum;

# Benefits
#
# Only requires perl5 (ubiquitous)
#
# Strong dryrun support - queries on filesystem will think they see the
# dryrun changes.
#
# Backups with undo support (almost complete)
#
# Windows support - including registry manipulation

# TODO !!!
#
# Better checksum support (SHA?)
#
# Strict checking on options - i've been burned by passing options that are
# silently ignored.
#
# info commands to learn available base command, module, module commands,
# and even command options.
#
# Should all commands follow-links for the initial target path (only
# recursive follow is off by default)? Safest to make these new commands -
# deprecate the old ones (file2, copy2 ..)
#
# Complete tracking changes in DRYRUN mode so that later file comparisons
# are made correctly - particulary copy is not tracked.
#
# Consistent path manipulation
#
# Implement undo from log
#
# Make Lock() follow cfengine's adaptive lock behavior:
# http://www.skipitaris.com/pub/lisa/main.html
#
# Re-evaluate flock use - didnt realize it was blocking. Right now I hold a
# lock on the checksum table - that is probably a problem.
#
# Filters like cfengine ... only better


use strict;

#----------------------------------------------------------------------
package Cf;

my $scriptdir;
BEGIN {
    # Add script's directory to module search path and PATH
    use FindBin;
    $scriptdir = $FindBin::Bin;
    push(@INC, "$scriptdir/lib/perl");
    if ($ENV{PATH} !~ /^$scriptdir:/) {
	# !!! this PATH is not ms-windows portable
	$ENV{PATH} = "$scriptdir:$ENV{PATH}";
    }
}

use AnyDBM_File;
use Cwd;
use English qw( -no_match_vars );
use Fcntl qw( :DEFAULT :flock);
use File::Compare;
use File::Copy;
use File::Path;
use File::Basename;
use File::Find;
use IPC::Open2;
use IPC::Open3;
use IO::File;

BEGIN {
    use Exporter ();
    use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);

    # set the version for version checking
    $VERSION     = 1.00;

    @ISA         = qw(Exporter);
    @EXPORT      = ( );
    %EXPORT_TAGS = ( );

    # your exported package globals go here,
    # as well as any optionally exported functions
    @EXPORT_OK   = ( );
}

#-----
# Globals

# Boolean: true if microsoft windows platform. Otherwise, a posix system is
# assumed.

my $is_win = ($^O eq 'MSWin32' || $^O eq 'cygwin');

# Is this the root user (or equivalent).
# Controls config settings, not special privileges, so we dont have
# to be too thorough (important be cause the check under windows
# is rather fuzzy)

my $is_root = ($UID == 0)
	|| ($is_win && ($ENV{USERNAME} eq "Administrator" || $UID == 500));

# Where to store our state files.

my $vardir = $ENV{CF_VARDIR};
if (!defined $vardir) {
    $vardir = $is_root ? '/var/lib/cf' : "$ENV{HOME}/.cf";
}

# base of configuration script/module tree

my $cfbase = $ENV{CF_BASEDIR};

# Modal flags
my %flags = (
    INFORM => 0,		# Notify of any changes made?
    DRYRUN => 0,		# If true, don't actually make changes
    DEBUG => 0,			# Display debugging output?
    LOG => 0,			# Log messages to system log
    NEW_TIME => 0,		# Update time when copying?
    COPY_TYPE => 'mtime',	# Method for comparing files
    VERIFY => 'none',		# Method for verifying files
    BACKUP => 'original',	# When to backup
    TEMPDIR => '',		# Where to put temp files
    DELETE_CORRUPT_DB => 0,	# Should we delete checksum database when it
    				# gets corrupts (and then retry)
    LOCK_EXPIRE => 60*60,	# Seconds before a lock holding process can
    				# be killed (default is 1 hour).
    LOCK_WAIT => 30,		# Seconds to wait before giving up on locks
    				# (default is 30 seconds).

    # For scf - never completed...
    SCF_SSH => 'ssh',	# ssh used for scf
    SCF_CF => 'cf',	# Path to cf on remote machines (scf)
);

# Boolean: actually perform updates (as opposed to going
# through the motions and reporting what would be done.)

my $update;

# Root of UNIX filesystem - under windows, will be replaced with the
# (windows) path to the cygwin root.

my $rootdir = '';
if ($is_win) {
    if (defined $ENV{CYGROOT}) {
	$rootdir = $ENV{CYGROOT};
    } elsif (-f "$vardir/cygroot") {
	$rootdir = RawReadFile("$vardir/cygroot");
	chomp($rootdir);
    } else {
	$rootdir = ReadCommand('cygpath -w /');
	$rootdir =~ s/\s*$//; # Trim trailing white space
	RealWriteFile("$vardir/cygroot", $rootdir);
    }
    $ENV{CYGROOT}= $rootdir;

}

# Maximum series of links to follow to find a real target (to avoid infinite
# link loops).
my $max_links = 10;

#--------

sub GetVarDir() { return $vardir };

#--------
# Parsing of configuration options.

sub parse_string { return $_[0] }
sub parse_int { return int($_[0]) }
sub parse_float { return $_[0]+0.0 }
sub parse_enum {
    my $arg = shift;
    foreach my $val (@_) {
	return $val if $arg eq $val;
    }
    die "bad choice: $arg (should be " . join(', ', @_), ")\n";
}

my %bools = (
    1 => 1, YES => 1, Y => 1, TRUE => 1,
    0 => 0, NO => 0, N => 0, FALSE => 0,
);
sub parse_bool { return $bools{uc($_[0])} }

sub parse_mode {
    my $mode = $_[0];
    # Make sure file mode numbers are interpreted in octal
    $mode = "0$mode" if ( $mode =~ /^[1-9]/ );
    return $mode;
}

push(@EXPORT, qw(&parse_string &parse_int &parse_float &parse_enum
	&parse_bool));

# Could break this up by operation... - but that would make it harder to avoid
# conflicts.
my %parse_opt = (
    OWNER => \&parse_string,
    USER => "OWNER",
    U => "OWNER",
    GROUP => \&parse_string,
    G => "GROUP",
    MODE => \&parse_mode,
    M => "MODE",
    DIRMODE => \&parse_mode,

    CHANGE_TYPES => '',
    CHANGETYPE => 'CHANGE_TYPES',
    CHECKTYPE => '!CHANGE_TYPES',

    SKIP_MISSING => '',
    SKIPMISSING => "SKIP_MISSING",

    PURGE => '',
    DELETE => "PURGE",
    D => "PURGE",
    PURGE_EXCLUDED => "PURGE=EXCLUDED",
    DELETE_EXCLUDED => "PURGE=EXCLUDED",

    RMDIR => '',

    FOLLOW_LINKS => '',
    FOLLOWLINKS => "FOLLOW_LINKS",
    FOLLOW => "FOLLOW_LINKS",
    NOFOLLOW => "!FOLLOW_LINKS",

    RECURSE => \&parse_int,
    R => "RECURSE",

    ROTATE => \&parse_int,

    ATIME => \&parse_float,
    AGE => "ATIME",
    MTIME => \&parse_float,
    CTIME => \&parse_float,

    INCLUDE => sub {
	my ($arg, $optref) = @_;
	push ( @{$optref->{EXCLUDE}}, InGlob($arg) );
	return undef;
    },
    I => "INCLUDE",
    EXCLUDE => sub {
	my ($arg, $optref) = @_;
	push ( @{$optref->{EXCLUDE}}, ExGlob($arg) );
	return undef;
    },
    E => "EXCLUDE",

    BACKUP => sub { parse_enum(uc($_[0]), 'ALL', 'ORIGINAL', 'LAST', 'NONE') },
    BACKUPDIR => \&parse_string,

    COPY_TYPE => sub { parse_enum(uc($_[0]),
	'MTIME', 'CKSUM', 'MD5', 'BINARY', 'HARDLINK', 'SOFTLINK',
    ) },
    COPYTYPE => 'COPY_TYPE',

    VERIFY => sub { parse_enum(uc($_[0]),
	'NONE', 'CKSUM', 'MD5', 'BINARY'
    ) },

    NEW_TIME => '',
    NEWTIME => 'NEW_TIME',

    'TOC_FIELD' => sub {
	my ($arg, $optref) = @_;
	push ( @{$optref->{TOC_FIELDS}},
		parse_enum(uc($arg), 'CKSUM', 'MD5')
		);
	return undef;
    },
    FIELD => 'TOC_FIELD',

    TIMEOUT => \&parse_int,
    CHDIR => \&parse_string,
    PREVIEW => '',
    SLOPPY_DAEMON => '',

    TEMPDIR => \&parse_string,

    UMOUNT => '',

    PREPEND => \&parse_bool,

    ONFAIL => sub { parse_enum(uc($_[0]),
	'ABORT', 'ERROR', 'WARNING', 'INFO'
    ) },
);

# Usage: get_options parser-hashref arg ..

sub get_options($@) {
    my $parse_href = shift;
    my %opts = ();
    while (@_[0] =~ /^-/) {
	my ($origopt,$arg) = split('=', shift(@_), 2);
	my $opt = uc($origopt);
	last if $opt eq '--';

	# Trim all leading dashes
	$opt =~ s/^-*//;
	# Replace remaining dashes with underscore
	$opt =~ s/-/_/g;

	my $parser = $parse_href->{$opt};

	if (!defined $parser) {
	    # Check if this is an implied variant for a boolean
	    # option
	    if ( $opt =~ /^NO_(.*)/ && defined $parse_href->{$1} ) {
		$opt = $1;
		$arg = 0;
	    } elsif ( $opt =~ /(.*)_IS$/ && defined $parse_href->{$1} ) {
		$opt = $1;
		$arg = parse_bool(shift(@_));
	    } else {
		die "bad option: $origopt\n";
	    }

	    # Follow trail of aliases and inversions till we get to real
	    # flag option
	    while (($parser = $parse_href->{$opt}) ne '') {
		if ($parser =~ /^(!)?(\w+)$/) {
		    $opt = $2;
		    $arg = !$arg if ($1 eq '!');
		} else {
		    die "bad option: $origopt\n";
		}
	    }
	    $opts{$opt} = $arg;
	    next;
	}

	if (!ref($parser)) {
	    if ($parser =~ /^!(.*)/) {
		# Inversion of flag option
		$opts{$1} = 0;
		next;
	    }
	    if ($parser =~ /^(\w*)=(.*)/) {
		# Option alias with implied value
		$opts{$1} = $2;
		next;
	    }

	    if ($parser ne '') {
		# Option is an alias - get parser from real option
		$opt = $parser;
		$parser = $parse_href->{$opt};
	    }

	    if ($parser eq '') {
		# Option does not take an argument - its a boolean flag
		$opts{$opt} = 1;
		next;
	    }
	}
	$arg = shift(@_) if not defined $arg;
	my $val = &$parser($arg, \%opts);
	$opts{$opt} = $val if defined $val;
    }
    return (\%opts, @_);
}
push(@EXPORT, '&get_options');

# Parse command line options.

my %global_opts = (
    INFORM => '',
    I => 'INFORM',

    DRYRUN => '',
    N => 'DRYRUN',
    DRY_RUN => 'DRYRUN',
    RECON => 'DRYRUN',
    TEST => 'DRYRUN',
    
    DEBUG => '',
    D => 'DEBUG',
    
    SPLAY => \&parse_int,

    LOG => \&parse_string,
);
sub parse_args(@) {
    my ($optref, @args) = get_options(\%global_opts, @ARGV);

    if ($optref->{SPLAY}) {
	# Introduce random delay up to $splay minutes - generally used to keep
	# all machines from hitting the cfmaster at the same time.
	sleep(rand($optref->{SPLAY}*60));
    }
    delete $optref->{SPLAY};

    # Remaining options are modal flags.
    Cf::SetFlagsFromHash(%{$optref});

    return @args;
}
push(@EXPORT, '&parse_args');

# Define result types for exported function - so that we can return results to
# command line scripts.

my %op_results = ();
my %op_briefs = ();

sub OpResult($) {
    my ($opname) = @_;
    return $op_results{$opname};
}

sub SetOpResult($$$$) {
    my ($package, $opname, $type, $brief) = @_;
    if ($package =~ /^Cf::Module::(.*)/) {
	$opname = "$1:$opname";
    }
    $op_results{$opname} = $type;
    $op_briefs{$opname} = $brief;
}

sub GetModuleOps($) {
    my ($module) = @_;
    my %results = ('configure', 'setup this module on host');
    foreach my $key (keys(%op_briefs)) {
	if ($key =~ /^$module:(.*)/) {
	    $results{$1} = $op_briefs{$key};
	}
    }
    return %results;
}

sub null_op($;$) {
    my ($opname, $brief) = @_;
    SetOpResult(caller(), $opname, undef, $brief);
}
push(@EXPORT, '&null_op');

sub string_op($;$) {
    my ($opname, $brief) = @_;
    SetOpResult(caller(), $opname, 'string', $brief);
}
push(@EXPORT, '&string_op');

sub boolean_op($;$) {
    my ($opname, $brief) = @_;
    SetOpResult(caller(), $opname, 'boolean', $brief);
}
push(@EXPORT, '&boolean_op');

# Update modal flags - each arguments if a mode flag optionally followed
# with "=" and a value. If no value is provided sets the flag to 1.

sub SetFlags(@) {
    foreach my $setting (@_) {
	next if $setting eq "";

	# get value for key (1 if not specified)
	my ($key, $value) = ($setting, 1);
	if ($setting =~ /(\w*)=(.*)/ ) {
	    # Value specified for key.
	    $key = $1;
	    $value = $2;
	}
	$key = uc($key);

	die "unknown flag: $key\n" unless defined $flags{$key};
	$flags{$key} = $value;
    }
    SetLogging($flags{LOG});
    $update = not $flags{DRYRUN};

    # Export new flags to environment
    my @new_env = ();
    foreach my $key (sort(keys(%flags))) {
	push(@new_env, "$key=$flags{$key}") unless ($flags{$key} eq '0');
    }
    my $flagstr = ":".join(':', @new_env).":";
    $ENV{CF_FLAGS} = $flagstr;
    Debug("flags are: $flagstr");
}

sub SetFlagsFromHash(%) {
    my (%h) = @_;
    my @flaglist = ();

    foreach my $key (keys(%h)) {
	push(@flaglist, "$key=".$h{$key});
    }
    if (@flaglist) {
	SetFlags(@flaglist);
    }
}

# Try to find named progam in listed directory. Return full path of program
# if succesful, otherwise throws an exception.

#sub FindProgram($@) {
#    my ($progname, @dirs) = @_;
#    my @endings = ($is_win) ? ('.exe', '.com', '.bat') : ('');
#    foreach my $dir (@dirs) {
#	foreach my $suffix (@endings) {
#	    my $path = $dir . "/$progname$suffix";
#	    Debug('trying (' . $dir . ') ' . $path);
#	    return $path if (-x $path && !(-d $path));
#	}
#    }
#    die "could not locate program $progname";
#}

#-------
# Path manipulation .. no longer used but should do something instead of the
# current adhoc manipulation.

#sub GetPath() {
#    my $sep = ($is_win) ? ';' : ':';
#
#    return split($sep, $ENV{PATH});
#}

#sub PrependPath(@) {
#    my $sep = ($is_win) ? ';' : ':';
#
#    $ENV{PATH} = join($sep, @_) . $sep . $ENV{PATH};
#}

# Convert native-OS or perl-style file path to cygwin-style path.

sub CygPath($) {
    my ($path) = @_;

    if ($is_win) {
	$path =~ s{\\}{/}g;
	$path =~ s{^([a-zA-Z]):/}{/cygdrive/$1/};
    }
    return $path;
}

sub cygpath {
    my ($optref, $path) = get_options({}, @_);
    return CygPath($path);
}
push(@EXPORT, '&cygpath');
string_op('cygpath');

# Convert cygwin-style file path to perl-style path.

sub UncygPath($) {
    my ($path) = @_;

    if ($is_win) {
	# Replacing /cygdrive/*/ with *:/

	$path =~ s{^/cygdrive/([a-zA-Z])/}{$1:/};

	if ( $path =~ m{^/[^/]} ) {
	    # Path is relative to UNIX (cygwin) root - prepend the root
	    # directory.
	    $path = $rootdir . $path;
	}
    }
    return $path;
}

# Convert perl-style or cygwin-style file path to native OS file path.

sub SysPath($) {
    my ($path) = @_;

    if ($is_win) {
	$path = UncygPath($path);
	$path =~ s{/}{\\}g;
    }
    return $path;
}

sub syspath {
    my ($optref, $path) = get_options({}, @_);
    return SysPath($path);
}
push(@EXPORT, '&syspath');
string_op('syspath');

# Convert native OS file path to perl-style path (replace any backslashes
# with forward slashes).

sub UnsysPath($) {
    my ($path) = @_;

    if ($is_win) {
	$path =~ s{\\}{/}g;
    }
    return $path;
}

#-------
# Introspective help

sub helpcommands {
    foreach my $cmd (sort(@EXPORT)) {
	$cmd =~ s/^&//;
	print "  $cmd\n";
    }
}
push(@EXPORT, '&helpcommands');

sub helpmodcommands {
    my ($o, $modname) = get_options({}, @_);
    my %briefs = GetModule($modname)->GetOps();

    foreach my $op (sort(keys(%briefs))) {
	print "$op - $briefs{$op}\n";
    }
}
push(@EXPORT, '&helpmodcommands');

sub helpmodules {
    my %modbriefs = ();
    my $base = GetBase();
    foreach my $script (
	    glob("$base/*/configure.pl"),
	    glob("$base/*/configure"),
	    ) {
	my $module = basename(dirname($script));
	open(FILE, "<$script") or die "can't open $module: $!\n";
	my ($brief) = grep("^#BRIEF:", split(<FILE>));
	$brief =~ s/^#BRIEF: *//;
	$modbriefs{$module} = $brief;
    }
    foreach my $module (sort(keys(%modbriefs))) {
	print "$module - $modbriefs{$module}\n";
    }
}
push(@EXPORT, '&helpmodules');

#-------
# Change tracking

# Return boolean: 1 if in update mode, 0 if in dry-run mode.

sub updating {
    my ($optref) = get_options({max=>0}, @_);
    return $update;
}
push(@EXPORT, '&updating');
boolean_op('updating');

# Get count of changes made so far. Handy to determine if system is actually
# changed during a routine (compare change count from start and end).

my $change_count;
my $change_file;
my $last_read_changes = 0;
sub ChangeCount() {
    if (!defined($change_count)) {
	if (defined $change_file) {
	    # In a multi-process configuration session - get changes from
	    # session state.
	    $last_read_changes = ReadFile($change_file);
	}
	$change_count = $last_read_changes;
    }
    return $change_count;
}

# Record that a configuration change has occured.

sub MarkChange(@) {
    Info(@_);
    ChangeCount();
    $change_count++;
    if (defined($change_file) && $change_count == $last_read_changes + 1) {
	# Always write out the first change after sync with change file - so
	# that if the process exits it will be noted that a change has
	# occured.
	RealWriteFile($change_file, $change_count);
    }
}

# Print count of config changes so far (or since prior invocation)

sub changes {
    my ($o, $initial) = get_options({}, @_);
    $initial = 0 unless defined $initial;
    return ChangeCount()-$initial;
}
push(@EXPORT, '&changes');
string_op('changes');

#-------
# Module management

# Hash of defined modules by name.
my %modules = ();

sub GetModule($) {
    my ($modname) = @_;
    return $modules{$modname} if defined $modules{$modname};

    my $base = GetBase();
    my $module;
    if (-f "$base/$modname/configure.pl") {
	Debug("load (perl) cf module $modname");
	$module = LoadPerlMod("$base/$modname/configure.pl");
    } elsif (-x "$base/$modname/configure") {
	Debug("load (script) cf module $modname");
	$module = new Cf::ScriptModule($modname, "$base/$modname/configure");
    } else {
	die "unknown module: $modname (base=$base)\n";
    }
    $modules{$modname} = $module;
    return $module;
}
sub get_module {
    my ($o, $name) = get_options({}, @_);
    return GetModule($name);
}
push(@EXPORT, '&get_module');

sub testmod {
    my ($optref, @modules) = get_options({}, @_);
    my $base = GetBase();
    if (scalar(@modules) == 0) {
	foreach my $script (
		glob("$base/*/configure.pl"),
		glob("$base/*/configure"),
		) {
	    push(@modules, basename(dirname($script)));
	}
    }
    foreach my $mod (@modules) {
	GetModule($mod);
    }
}
push(@EXPORT, '&testmod');

sub CallModule($$@) {
    my ($modname, $function, @args) = @_;

    # Make sure we have a session
    GetSession();

    my $module = GetModule($modname);
    return $module->call($function, @args);
}
sub call_module {
    my ($o, $name, $function, @args) = get_options({}, @_);
    return CallModule($name, $function, @args);
}
push(@EXPORT, '&call_module');

# If specified file exists read simple config settings from the file (var=val)
# a return list of alternative setting names and values.

sub LoadVars($) {
    my ($file) = @_;
    return unless -f $file;
    open(FILE, "<$file") or die "can't open $file: $!\n";
    my @vals = ();
    while (my $line = <FILE>) {
	next if $line =~ /^\s*$/;	# Skip empty lines
	next if $line =~ /^\s*#/;	# Skip comments
	$line =~ s/[\cM\cJ]*$//;	# chomp() for any text format
	my ($key, $val) = split('=', $line, 2);
	push(@vals, $key, $val);
    }
    close(FILE) or die $!;
    return @vals;
}

sub load_vars {
    my ($optref, $path) = get_options({}, @_);
    return LoadVars($path);
}
push(@EXPORT, '&load_vars');


# Hash of hashes. Key is module name, each value is a reference to another
# hash that maps variable names to values.
my %host_modvars = ();
my $host_modvars_loaded = 0;

# Load host-specific settings for modules from host's ini file.
# host.ini files. 
sub LoadHostVars() {
    return if $host_modvars_loaded;

    my $basedir = GetBase();
    my $host = get_host();
    my $masterfile = "$basedir/PERHOST/$host.ini";

    if (-f $masterfile) {
	# Reference to variable hash currently being loaded
	my $var_href;

	open(FILE, "<$masterfile") or die "can't open $masterfile: $!\n";
	while (my $line = <FILE>) {
	    next if $line =~ /^\s*$/;   # Skip empty lines
	    next if $line =~ /^\s*#/;   # Skip comments
	    if ($line =~ /^\[(\w+)\]/) {
		# New module section - open new target file
		my $modname = $1;
		$var_href = {};
		$host_modvars{$modname} = $var_href;
		next;
	    }

	    $line =~ s/[\cM\cJ]*$//;	# chomp() for any text format
	    if (!defined $var_href) {
		die "definition without section in $masterfile: $line\n";
	    }
	    my ($key, $val) = split('=', $line, 2);
	    $var_href->{$key} = $val;
	}
    }
    $host_modvars_loaded = 1;
}

# Get host specifc variable settings for specified module.
sub GetHostVars($) {
    my ($modname) = @_;
    
    LoadHostVars();

    my $href = $host_modvars{$modname};
    if (defined $href) {
	return %{ $href};
    } else {
	return ();
    }
}

sub LoadPerlMod($) {
    my ($script) = @_;
    my $dir = AbsolutePath(dirname($script));
    my $name = basename($dir);

    my $package = "Cf::Module::$name";
    my $module = new Cf::ModuleWrap($name, $package);

    my $global_defs = "";
    my %vars = (LoadVars("$dir/site.ini"), GetHostVars($name));
    foreach my $key (keys(%vars)) {
	die "bad variable name in module $name: $key\n" unless $key =~ /^\w+$/;
	if ($key =~ /^svc_/) {
	    eval { Cf::GetModule($vars{$key}) };
	    if (my $err = $@) {
		# Skip definition if module not found - it might be a
		# compile-only module.
		next if $err =~ /^unknown module:/;

		die $err;
	    }
	    $global_defs .= sprintf('my $%s = Cf::GetModule(\'%s\');',
		    $key, $vars{$key});
	} else {
	    $global_defs .= sprintf('my $%s = \'%s\';', $key, $vars{$key});
	}
    }
    eval "package $package;"
	. 'use strict;'
	. 'BEGIN { import Cf; }'
	. 'my $this_svc = $module;'
	. 'my $this_dir = $dir;'
	. 'my $this_vars = \%vars;'
	. $global_defs
	. Cf::ReadFile($script);
    if (my $err = $@) {
	die "while loading $script: $@";
    }
    return $module;
}

# Make sure requested modules have been configured (if they haven't configure
# them now)

sub requiremodule {
    my ($optref, @modules) = get_options({}, @_);
    foreach my $module (@modules) {
	GetModule($module)->require();
    }
}
push(@EXPORT, '&requiremodule');

# Configure all (appropriate) services
sub all {
    my ($optref) = get_options({}, @_);

    # Make sure we have a session.
    GetSession();

    my $host = get_host();
    # !!! don't like this location for all services - invading the otherwise
    # independent cf service
    my $svfile = GetBase() . "/cf/PERHOST/$host/services";
    die "no configuration defined for this host: $host\n" unless (-f $svfile);

    my $lock = new Cf::Lock("all");

    open(FILE, "<$svfile") or die $!;
    my @svcs = <FILE>;
    my @failed = ();
    close(FILE) or die $!;
    foreach my $svc (@svcs) {
	$svc =~ s/[\cM\cJ]*$//;		# chomp() for any text format
	eval { GetModule($svc)->require(); };
	if (my $err = $@) {
	    push(@failed, $svc);
	    Error("configure of $svc failed: $err");
	}
    }
    if (@failed) {
	die("failed to configure: ", join(" ", @failed), "\n");
    }
}


#-------
# Miscellaneous admin utilities.

# Usage: DisplayMessage($message)
# Display message box in background (spawn a separate process).
# Windows only for now - do I want something similar for UNIX? Send mail to
# logged in users instead (could extend to include people using various
# services like samba ...)?

#sub DisplayMessage($) {
#    my $message = shift();
#    my $pobj;
#
#    Sendmail("cfengine notice", $message, LocalUsers());
#}


#my @users;
#sub LocalUsers() {
#    if (!scalar(@users)) {
#	if ($is_win) {
#	    require Win32::NetAdmin;
#	    Win32::NetAdmin::LoggedOnUsers('', \@users);
#	} else {
#	    my %uflag = ();
#	    foreach my $line (split("\n", ReadCommand("who"))) {
#		if ($line =~ /^(\w+)/) {
#		    $uflag{$1} = 1;
#		}
#	    }
#	    @users = keys(%uflag);
#	}
#    }
#    return @users
#}


#sub Sendmail($$@) {
#    require Mail::Sender;
#
#    my ($subject, $message, @recipients) = @_;
#    my $sender = new Mail::Sender( {smtp => 'mailhost'} );
#    die "Mail failed: $Mail::Sender::Error" if !ref($sender);
#
#    my $user = 'nobody';
#    foreach my $varname ('LOGNAME', 'USERNAME') {
#	if ($ENV{$varname}) {
#	    $user = $ENV{$varname};
#	    last;
#	}
#    }
#
#    # Send the mail.
#    my $result = $sender->MailMsg( {
#	    to => join(', ', @recipients),
#	    from => $user,
#	    subject => $subject,
#	    msg => $message,
#	    } );
#    die "Mail failed: $Mail::Sender::Error" if !ref($result);
#}


#----------------------------------------------------------------------
# Windows Registry utility routines.

# Get reference to named (relative to root) key in registry. Returns key
# reference.

sub get_registry($) {
    my ($optref, $path) = get_options({}, @_);

    if (!defined $Cf::Registry) {
	# Load registry.

	require Win32;
	require Win32::TieRegistry;
	import Win32::TieRegistry(Delimiter => '/', SplitMultis => 1);
    }

    # I have to use the fully qualified name for Registry as it is
    # dynamically imported - is there some way to avoid coding in the
    # package name here?
    my $key = $Cf::Registry->{$path} 
	or die "can't open registry key, $path: $^E\n";

    return $key;
}
push(@EXPORT, '&get_registry');

# !!! Stupid perl - TieRegistry does an eval in its DESTROY method to any of
# those onjects on your stack can cause exceptions to be mysteriously lost!!
# So keep the keys in globals.
my $setreg_key;

sub setregistry {
    my ($optref, $path, $val) = get_options( {TYPE => \&parse_string,}, @_);
    my $type = $optref->{TYPE} || "SZ";
    my $keypath = dirname($path);
    my $name = basename($path);
    $setreg_key = get_registry($keypath);
    set_registry($setreg_key, $name, $val, "REG_$type");
}
push(@EXPORT, '&setregistry');

# Set registry values as defined in source file.

my $loadreg_key;
sub loadregistry {
    my ($optref, $path) = get_options( {}, @_);
    my $lnum = 0;
    foreach my $line (split("\n", ReadFile($path))) {
	$lnum += 1;

	next if $line =~ /^\s*$/; # skip empty lines
	next if $line =~ /^#/; # skip comments

	if ($line =~ /^\[(.*)\]$/) {
	    # New group - update base key location
	    $loadreg_key = get_registry($1);
	    die "unknown registry key: $1" unless defined $loadreg_key;
	    next;
	}

	my ($name, $x, $type, $val)
		= ($line =~ /^([^=]*)\s*=\s*((\w+):)?(.*)/)
		or die "bad line in reg file: $path:$lnum\n";
	$type = defined($type) ? "REG_".uc($type) : "REG_SZ";
	set_registry($loadreg_key, $name, $val, $type);
    }
}
push(@EXPORT, '&loadregistry');

# Usage: SetRegistry($key, $name, $value, $type)
# Make sure registry item has specified value/type. Create ancestral subkeys
# as required.

sub set_registry($$$$) {
    my ($key, $name, $value, $type) = @_;
    my $keypath = $key->Path();
    my $message = "setting $keypath$name to ";
    my ($delim) = $key->GetOptions('Delimiter');

    # If registry type is dword, make sure value is hexadecimal formatted.

    if ($type eq 'REG_DWORD' && $value !~ /^0x/) {
	$value = sprintf("0x%4.4x", $value);
    }

    # Check if current value matches desired one - if so return, otherwise
    # append to message saying what the new and old values are.

    if ($type eq 'REG_MULTI_SZ') {
	debug("checking that $keypath$name is @{$value}");
	my $oldref = $key->{$name};
	if (defined($oldref)) {
	    return if (join("\0", @{$value}) eq join("\0", @{$oldref}));
	} else {
	    $oldref = [];
	}
	$message .= "@{$value} ($type) (old was @{$oldref})";
    } else {
	debug("checking that $keypath$name is $value");
	my $old = $key->{$name};
	if (defined($old)) {
	    if ($type eq 'REG_DWORD') {
		return if ( hex($old) == hex($value) );
	    } else {
		return if ( $old eq $value );
	    }
	} else {
	    $old = '';
	}
	$message .= "$value ($type) (old was $old)";
    }

    # Split name into list of subkeys and the item name.

    my @subkeys = split($delim, $name);
    my $item = pop(@subkeys);

    # Inform what keys will be created.

    my $subpath = '';
    foreach my $subkey (@subkeys) {
	$subpath .= $subkey . $delim;
	if ( !defined($key->{$subpath}) ) {
	    MarkChange("creating registry key $keypath$subpath");
	}
    }
    MarkChange($message);

    return unless ( $update );

    foreach my $subkey (@subkeys) {
	my $nextkey = $key->{"$subkey$delim"};
	if (!defined($nextkey)) {
	    $nextkey = $key->CreateKey($subkey)
		    or die "failed to create registry key, $subkey: $^E\n";
	}
	$key = $nextkey;
    }
    $key->SetValue($item, $value, $type)
	    or die "failed to set registry, $item/$value: $^E\n";
}
push(@EXPORT, '&set_registry');

# Delete specified item from registry.

sub delete_registry($$) {
    my ($key, $name) = @_;

    return if !defined($key->{$name});

    MarkChange("deleting ", $key->Path(), $name);
    return unless ( $update );

    delete $key->{$name};
}
push(@EXPORT, '&delete_registry');

# Flush all registry updates, and perform a 'RegFlushKey' on the specified
# registry key.

sub flush_registry($) {
    my ($key) = @_;

    Debug("flushing ", $key->Path());
    return unless ( $update );

    $Cf::Registry->Flush();
    $key->RegFlushKey();
}
push(@EXPORT, '&flush_registry');


#----------------------------------------------------------------------
# Logging


my $logging = '0';
my $logtype = 'none';
my $logfh;

# logfile used when logtype is "file"
my $logfile = "$vardir/log";

# Define whether we are logging to the system log (and how).

sub SetLogging($) {
    my ($newlog) = @_;

    return if ($newlog eq $logging);
    if ($newlog =~ /^syslog(:(.*))?/) {
	my $facility = $2 || 'user';

	require Sys::Syslog;
	import Sys::Syslog;

	# Open connectio to system log - make sure to use unix domain
	# socket as secure configurations (redhat linux) default to
	# rejecting network log messages.

	Sys::Syslog::setlogsock('unix');
	openlog(basename($0), 'pid', $facility);
	$logtype = 'syslog';

	# Close file log.
	if (defined $logfh) {
	    close($logfh);
	    $logfh = undef;
	}
    } else {
	closelog() if $logtype eq 'syslog';

	if ($newlog eq "1") {
	    $logtype = 'file';
	} elsif ($newlog eq "0") {
	    $logtype = 'none';
	} else {
	    die "invalid logging value: $logging\n";
	}
    }
    $logging = $newlog;
    Debug("logging changed to $logging");
}

# Log a message

sub Log ($$$@)
{
    my ($fh, $file_level, $priority, @msgs) = @_;
    my $message = join('', @msgs);

    my $maxlen = 900;
    my @messages = ();

    # Save log message only if this run is for real.
    if ($logtype ne 'none' && $update) {
	if ($logtype eq 'syslog') {
	    # Write message to system log.

	    # Syslog splits messages over UDP packet length - split before
	    # ourselves so there is enough information to join them again

	    my $tail = $message;
	    while (length($tail) > $maxlen) {
		push(@messages, (substr($tail, 0, $maxlen) . "..."));
		$tail = ("..." . substr($tail, $maxlen));
	    }
	    push(@messages, $tail);

	    # I have occasional times when syslog will throw an exception -
	    # if it does fall back to writing to stdout/stderr.

	    eval {
		foreach my $submessage (@messages) {
		    syslog($priority, '%s', $submessage);
		}
	    };
	    if (my $err = $@) {
		print(STDERR ":error:syslog failed:$err\n");
	    } else {
		return;
	    }
	} else {
	    # Write to our own log.
	    if (!defined $logfh) {
		$logfh = new IO::File;
		RealMakeDir($vardir);
		open($logfh, ">>$vardir/log")
		    or die "can't append to $vardir/log\n";
		$logfh->autoflush(1);
	    }
	    my $tstamp = time();
	    print($logfh "$tstamp $file_level $message\n");
	}
    }

    # Check that display of this type of message is enabled.
    return if ($priority eq 'info' and !$flags{INFORM});
    return unless defined $fh;

    # Display message.
    # !!! Note that the format of this message is (was) designed to work
    # nicely as a cfengine "preview" shellcommand.

    print($fh ":$file_level:$message\n");
}

sub showlog {
    die "can't display log for type=$logtype\n" unless $logtype eq 'file';
    open(FILE, "<$logfile") or die "can't open $logfile\n";
    while (my $line = <FILE>) {
	my ($tstamp, $rest) = split(' ', $line, 2);
	my $timestr = localtime($tstamp);
	print "[$timestr] $rest";
    }
    close(FILE) or die $!;
}
push(@EXPORT, '&showlog');

sub Error {
    Log(*STDERR, 'error', 'err', @_);
}

sub Warn {
    Log(*STDERR, 'warn', 'warning', @_);
}

sub Info {
    Log(*STDERR, 'info', 'info', @_);
}

sub Debug {
    if ($flags{DEBUG}) { Log(*STDERR, 'debug', 'debug', @_); }
}

sub Undo {
    my @args = ();
    foreach my $arg (@_) {
	push(@args, Encode($arg));
    }
    Log(undef, 'undo', 'notice', join(' ', @args));
}

# Handle failure according to ONFAIL option $action.

sub Fail($$) {
    my ($action, $message) = @_;

    if ($action eq 'ABORT') {
	die $@;
    } elsif ($action eq 'ERROR') {
	Error($@);
    } elsif ($action eq 'WARNING') {
	Warn($@);
    } elsif ($action eq 'ERROR') {
	Error($@);
    } elsif ($action eq 'INFO') {
	Info($@);
    } else {
	die "unknown Fail action: $action. $@";
    }
}

#----------------------------------------------------------------------
# File utilities (internal) - don't obey operational modes, convergence,
# or other nice policies.

# Write content (with trailing newline) to a file.

sub RealWriteFile($$) {
    my ($path, $content) = @_;

    RealMakeDir(dirname($path));
    open(FILE, ">$path") or die "can't write to $path: $!\n";
    print(FILE $content) or die $!;
    if (length($content)) {
	print(FILE "\n") or die $!;
    }
    close(FILE) or die $!;
}

# Recursive delete. Does not follow symlinks.

sub RealRemoveTree($) {
    my ($dir) = @_;

    if ( (! -l $dir) && -d _ ) {
	rmtree($dir, 0, 0);
    } else {
	unlink($dir);
    }
    die "can't remove $dir: $!" if (-l $dir || -e _);
}

sub RealMakeDir(@) {
    foreach my $dir (@_) {
	mkpath($dir);
	die "can't create $dir: $!\n" unless (-d $dir);
    }
}

# Read contents of named file, and return contents with trailing newline
# removed.

sub ReadFile {
    my ($filename) = @_;
    if (!$update) {
	$filename = GetFake($filename);
    }
    my $contents = RawReadFile($filename);
    chomp($contents);
    return $contents;
}
sub read_file {
    my ($optref, $path) = get_options({}, @_);
    ReadFile($path);
}
push(@EXPORT, '&read_file');

sub RawReadFile {
    my ($filename) = @_;
    open(FILE, "<$filename") or die "can't open $filename: $!";
    my $contents = join('', <FILE>) ;
    close FILE;
    return $contents;
}

# Determine mount point of filesystem for specified path.

my %fsroot = ();	# Cache of device # to base path
sub getmount {
    my ($optref, $path) = get_options({}, @_);

    # If path does not exist yet find parent dir that does
    my @st;
    while (!(@st = stat($path))) {
	$path = dirname($path);
    }
    # Get device number of path
    my ($origdev, $origino) = @st;
    my $root = $fsroot{$origdev};

    if (!defined $root) {
	# Get canonical path
	my $dir = (-d $path) ? $path : dirname(FollowLinks($path));
	my $wd = cwd();
	chdir($dir) or die "can't chdir to $dir: $!";
	$dir = cwd();
	chdir($wd) or die "can't chdir to $wd: $!";

	$root = $dir;
	while (1) {
	    # Get parent dir.
	    $dir = dirname($root);

	    # Stop if we are at the root of this path.
	    last if $dir eq $root;

	    # Stop if parent dir is on a new device
	    my ($dev, $ino) = lstat($dir);
	    last if $dev != $origdev;

	    $root = $dir;
	}
	$fsroot{$origdev} = $root;
    }
    return $root;
}
push(@EXPORT, '&getmount');
string_op('getmount');

sub IsMount($) {
    my ($path) = @_;
    return 0 if ! -d $path;
    return (!-l $path && (getmount($path) ne getmount("$path/..")));
}

# Get temporary path where we can prep a file before renaming it atomically
# to the specified destination

sub TempName($%) {
    my ($dest, %opts) = @_;
    my $tempdir = $opts{TEMPDIR} || $flags{TEMPDIR};
    my $suffix = $opts{TEMPSUFFIX} || "-cfnew";

    die "empty destination for TempName()" unless (length($dest));

    # Remove any trailing /s on path (so we can append to the basename)
    $dest =~ s{/+$}{};
    die "can't create temp for root directory\n" if $dest eq "";

    my $path = "$dest$suffix";
    if (length($tempdir)) {
	# Want temporary files in alternate directory (default is the same
	# directory as the destination)
	if ($tempdir =~ m{\^/(.*)} ) {
	    $tempdir = getmount(dirname($dest)) . "/$1";
	}
	MakeDir($tempdir, FOLLOW_LINKS=>1);
	$path = "$tempdir/".basename($path);
    }

    if ( -e $path ) {
	# Temporary path already exists - remove it (assume it is from a
	# prior aborted run ... is this reasonably safe?).
	RemoveFile($path, 'BACKUP' => 'NONE');
    }
    return $path;
}

##--------
## Database (hash in file) manipulation

# Tie hash to database file - never mind the type. Acquires an exclusive lock
# on the database file too.

my %tieinfo = ();
sub TieFile(\%$) {
    my ($mapref, $path) = @_;

    return if tied %{$mapref};
    Debug("tieing $path");

    RealMakeDir(dirname($path));
    my $lock = "$path.lock";
    my $lockfh = new IO::File;
    open ($lockfh, ">>$lock") or die "can't open $lock: $!\n";
    flock($lockfh, LOCK_EX) or die "can't lock $lock $!\n";
    tie(%{$mapref}, 'AnyDBM_File', $path, O_CREAT|O_RDWR, 0644)
	    or die "can't open $path: $!\n";
    $tieinfo{$mapref} = [$path, $lockfh];
}

# Release tie to database file.

sub UntieFile(\%) {
    my ($mapref) = @_;

    return unless tied %{$mapref};

    my ($path, $lockfh) = @{ $tieinfo{$mapref} };
    my $lock = "$path.lock";

    Debug("untie-ing $path");

    untie %{$mapref};
    flock($lockfh, LOCK_UN) or die "can't unlock $lock $!\n";
    close($lockfh) or die $!;
    delete $tieinfo{$mapref};
}

# Kill specified process (assuming it exists) and verify that process no
# longer exists. Tries escalating series of signals. Returns 1 if process is
# gone, 0 if process would not die.

sub VerifiedKill($) {
    my ($pid) = @_;

    kill('INT', $pid);
    kill(0, $pid) or return 1; # Return 1 if process cannot be reached

    sleep(2);

    kill('TERM', $pid);
    kill(0, $pid) or return 1; # Return 1 if process cannot be reached

    sleep(2);

    kill('KILL', $pid);
    kill(0, $pid) or return 1; # Return 1 if process cannot be reached

    sleep(1);

    kill(0, $pid) or return 1; # Return 1 if process cannot be reached

    # We failed
    return 0;
}

# Backup specified file according provided options. Will use a hard link for
# the backup if possible so link needs to be broken before updating path.
#
# WARNING! May actually remove the location (if the target is a directory
# and the backup area is in the same filesystem)
#
# Supported options:
#
#	BACKUPDIR	Where to store backups
#
#	BACKUP		Mode of backups:
#
#		ALL - keep backup of all versions of a path
#		ORIGINAL - keep just the first version of a path
#		LAST - keep just the most recent version
#		NONE - don't keep any backups (BEWARE!)

sub Backup($%) {
    my ($path, %opts) = @_;
    $path = AbsolutePath($path);
    my $bdir = $opts{BACKUPDIR} || "$vardir/backup";
    my $mode = $opts{BACKUP} || uc($flags{BACKUP});


    my $finfo = GetFileInfo($path);
    my $type = $finfo->type;
    if ($type eq 'NONE') {
	Undo('tidy', $path);
	return;
    }
    if ($mode eq 'NONE') {
	Undo('warn', "$path can't be restored (no back up)");
	return;
    }
    die "can't backup $type file: $path"
	   if ($type ne 'FILE' && $type ne 'DIR' && $type ne 'LINK');

    my $dirname = dirname($path);
    my $basename = basename($path);

    # Determine full path to backup directory
    if (IsAbsolute($bdir)) {
	# Nothing to do
    } elsif ($bdir =~ m{\./(.*)}) {
	# Relative path
	$bdir = "$dirname/$1";
    } else {
	die "unrecognized format for BACKUPDIR: $bdir\n";
	# !!! would be nice to have an option to save at base of filesystem
    }

    # Open and lock backup directory. Create directory if it doesn't exist.

    RealMakeDir($vardir);
    RealMakeDir($bdir);
    my %pathmap;
    TieFile(%pathmap, "$vardir/backup.map");

    eval { BACKUP: {
	# Determine backup path

	my $bpath;
	if ($mode eq 'LAST' ) {
	    if (defined $pathmap{$path}) {
		# Backup already exists for this path - reuse that backup
		# location.
		$bpath = $pathmap{$path};
	    }
	} elsif ($mode eq 'ORIGINAL' ) {
	    # Skip if path has already been backed up.
	    if (defined $pathmap{$path}) {
		Undo('warn', "$path can't be restored (no back up)");
		last BACKUP;
	    }
	} elsif ($mode ne 'ALL') {
	    die "unknown backup mode: $mode\n";
	}

	if (!defined $bpath) {
	    # No backup path yet - get one that does not exist yet.

	    my $base = "$bdir/$basename";
	    $bpath = $base;
	    my $count = 1;
	    while (-e $bpath) {
		# keep counting
		$count += 1;
		$bpath = "$base-$count"
	    }
	}

	# Do the backup

	Debug("backing up $path to $bpath");

	# Make sure nothing in the backup location
	RealRemoveTree($bpath);

	my @undo_opts = (
	    -user => $finfo->uid,
	    -group => $finfo->gid,
	    -mode => sprintf("0%03o", $finfo->perm),
	    -mtime => $finfo->mtime,
	);

	if ($type eq 'LINK') {
	    # Really a link - nothing to backup.
	    Undo('link', @undo_opts, ReadLink($path), $path);
	} elsif ($type eq 'DIR') {
	    # path is a directory

	    if (rmdir($path) ) {
		Undo('mkdir', @undo_opts, $path);
	    } else {
		# simple delete failed - directory probably not empty
		# try moving it.

		if (rename($path, $bpath)) {
		    Undo('move', @undo_opts, $bpath, $path);
		} else {
		    # Can't move the directory - try archiving it.

		    Undo('untar', $bpath, $path);
		    my $wd = cwd();
		    chdir($dirname) or die "can't chdir to $dirname: $!";
		    my $rc = system('tar', '-cf', $bpath, $basename);
		    chdir($wd) or die "can't chdir to $wd: $!";

		    die "backup tar failed: $?" unless $rc == 0;
		}
	    }
	} else {
	    # Normal file
	    # Try doing the backup with a hard link unless the file already has
	    # a hard link. If linking does not work just do a copy.

	    # Does not restore hard links :-(
	    Undo('copy', @undo_opts, $bpath, $path);

	    if ($finfo->nlink != 1 || !link($path, $bpath)) {
		File::Copy::copy($path, $bpath)
		    or "failed to backup $path to $bpath: $!\n";
	    }
	}

	$pathmap{$path} = $bpath;
    } };
    {
	my $err =$@;
	UntieFile(%pathmap);

	# Throw error if backup failed
	die $err if $err;
    }
}

# Remove obsolete entries from the backup index (files purged from the backup
# directory(s)).

sub PurgeBackupIndex() {
    my %pathmap;
    TieFile(%pathmap, "$vardir/backup.map");
    while (my ($path, $bpath) = each(%pathmap)) {
	unless (-e $bpath) {
	    Debug("purging backup entry for $bpath");
	    delete $pathmap{$path} unless (-e $bpath);
	}
    }
    UntieFile(%pathmap);
}

sub MoveOld($%) {
    my ($path, %opts) = @_;
    my $old = TempName($path, %opts, TEMPSUFFIX=>"-cfold");
    RealRemoveTree($old) if (stat($old));
    rename($path, $old) or die "can't move $path to $old: $!\n";
    return $old;
}

# Move temp file into its permanent location. First check that the file has
# the appropriate attributes (matching passed options).

sub MoveTemp($$%) {
    my ($tmp, $target, %opts) = @_;

    # (Silently) set attributes of temp file.
    my $inform = $flags{INFORM};
    $flags{INFORM} = 0;
    CheckFile($tmp, %opts, RECURSE=>0, TARGETPATH=>$target);
    $flags{INFORM} = $inform;

    my $umount_tries = 0;
    while (IsMount($target) ) {
	die "can't replace mount point: $target\n" unless ($opts{UMOUNT});
	if ($umount_tries++ == 4) {
	    die "too many mounts on $target\n";
	}
	run('umount', $target);
    }

    Backup($target, %opts);
    my $old;
    if (-l $target || -d _) {
	# Target is a link or directory - can't replace with rename. Move
	# target out of the way and we will remove the tree after temp is in
	# place.
	$old = MoveOld($target, %opts);
    }
    my $rc = rename($tmp, $target);
    if (!$rc && (-l $target || -e _)) {
	# Move failed and target location exists
	# Try moving target out of the way instead of deleting (if this is
	# cygwin may be locked by nasty OS).
	$old = MoveOld($target, %opts);
	$rc = rename($tmp, $target);
	
    }
    die "can't move $tmp to $target: $!\n" if !$rc;

    if ($old) {
	RealRemoveTree($old);
    }
}

sub CheckType($$%) {
    my ($path, $desired_type, %opts) = @_;

    my $type = GetFileInfo($path)->type;
    if ( !$opts{CHANGE_TYPES} and ($type ne 'NONE')
	    and ($type ne $desired_type) ) {
	die "type mismatch, $path is $type (not $desired_type)\n";
    }
    return $type;
}

sub IsAbsolute($) {
    my ($path) = @_;
    if ($is_win) {
	$path = UnsysPath($path);
	return ( $path =~ m{^[A-Za-z]:/} || $path =~ m{^/} );
    } else {
	return ( $path =~ m{^/} );
    }
}
# ???
#sub is_absolute($) {
#    return File::Spec->file_name_is_absolute(@_);
#}

sub AbsolutePath($;$) {
    my ($path, $base) = @_;

    return $path if (IsAbsolute($path));
    $base = cwd() if not defined $base;
    $path = $base . '/' . $path;
    return $path;
}



# File Querying
#
# Want to cache file attributes - mostly for query network repositories and
# for faking updates in dry run mode. Problem is ... don't want to
# over-cache and get stale data.
#
# Also - don't want to load all cache attributes at the same time - 
# checksum in particular


# Stored file information, indexed by absolute (canonical) path
my %file_info = ();

sub ReadDir {
    my ($path) = @_;
    if (defined $file_info{$path}) {
	my $childref = $file_info{$path}->dir;
	if ($file_info{$path}->type eq 'DIR' && !defined $childref) {
	    LoadDirTOC($path);
	    $childref = $file_info{$path}->dir;
	}
	return @{$childref};
    }

    my @children = ();

    # Get all children of directory, except "." and ".."
    my %skip = ( "." => 1, ".." => 1,);
    opendir(DIR, $path) or die "$!: $path\n";
    while ( defined(my $child = readdir(DIR)) ) {
	push(@children, $child) unless $skip{$child};
    }
    closedir(DIR);

    return @children;
}
sub read_dir {
    ReadDir(@_);
}
push(@EXPORT, '&read_dir');

sub ReadLink ($) {
    my ($path) = @_;

    return $file_info{$path}->linkdest if (defined $file_info{$path});
    return readlink($path);
}

sub MD5 ($) {
    my ($path) = @_;
    return $file_info{$path}->md5 if (defined $file_info{$path});

    require Digest::MD5;

    open(FILE, $path) or die $!;
    binmode(FILE);
    my $sum = Digest::MD5->new->addfile(*FILE)->digest;
    close(FILE) or die $!;
    return $sum;
}

sub FileDigest($$) {
    my ($algorithm, $path) = @_;
}

##--------
## Checksum cache
## track file checksums and avoid recomputing if the file modtime is unchanged.

my %cksums = ();
my $cksum_deletes = 0;	# How many times have we deleted corrupt tied=db ?
my $cksum_lock;		# Cf lock on the checksum table.

# Open checksum db and tie to %cksums.
sub TieCksum() {
    if (!defined $cksum_lock) {
	# Acquire high-level lock - this allows other cf sessions to kill us
	# if we hang too long (without it the flock() that TieFile does will
	# block indefinitely)
	$cksum_lock = new Cf::Lock("_checksum");
    }
    TieFile(%cksums, "$vardir/cksum");
}

sub UntieCksum() {
    UntieFile(%cksums);
    $cksum_lock = undef;
}

# Lookup checksum (and modtime) from checksum cache

sub GetCksum($) {
    my ($path) = @_;
    TieCksum();
    return split(' ', $cksums{$path}, 2);
    # or use unpack() / pack ?
}

# Add entry to checksum cache.

sub SetCksum($$$) {
    my ($path, $sum, $mtime) = @_;
    TieCksum();
    if (defined $sum) {
	Debug("about to set cksum of $path to '$sum $mtime'");
	my $status = ($cksums{$path} = "$sum $mtime");
	if (!defined $status) {
	    # Annoying - sometimes updates to database files fail and there
	    # is no rhyme or reason (seeing this problem with berkeley db) -
	    # removing the cache seems to fix it. Try removing the cksum
	    # file but only try once per run:

	    die "failed to set cksum for $path\n"
		    unless $flags{DELETE_CORRUPT_DB};

	    if ($cksum_deletes > 0) {
		die "failed to set cksum for $path (already removed db): $!\n";
	    }

	    # Delete the database files
	    Warn("removing corrupt cksum files");
	    UntieCksum();
	    foreach my $file (glob("$vardir/cksum*"))  {
		unlink($file) or die "can't remove $file: $!\n";
	    }
	    $cksum_deletes += 1;
	    TieCksum();

	    # Try the update again
	    $status = ($cksums{$path} = "$sum $mtime");

	    if (!defined $status) {
		die "failed to set cksum for $path (after deleting db): $!\n";
	    }
	}
    } else {
	delete $cksums{$path};
    }
    # or use unpack() / pack ?
}

# Remove obsolete entries from the checksum cache.
sub PurgeCksum() {
    TieCksum();
    while (my ($path, $info) = each(%cksums)) {
	my ($sum, $mtime) = split(' ', $cksums{$path}, 2);
	my $fi = GetFileInfo($path);
	unless ($fi->mtime == $mtime) {
	    Debug("purging cksum for $path");
	    delete $cksums{$path};
	}
    }
}

my $cksum_ref;
sub Cksum ($) {
    my ($path) = @_;

    # If file info is cached use that cksum (even if none there).
    return $file_info{$path}->cksum if (defined $file_info{$path});

    my $fi = GetFileInfo($path);

    # checksums only make sense for true files - return undef for others.
    return undef unless $fi->type eq 'FILE';

    # Look for checksum in file cache - use cached value if file modtime has
    # not changed since the cached was computed.
    my ($sum, $mtime) = GetCksum($path);
    if ($mtime == $fi->mtime) {
	Debug("using cached cksum for $path ($sum)");
	return $sum;
    }

    if (not defined $cksum_ref) {
	# figure out how to compute checksum
	eval {
	    require String::CRC::Cksum;
	};
	if (my $err = $@) {
	    # Can't load perl module - use external command instead.
	    Debug("String::CRC::Cksum is not available");
	    $cksum_ref = \&CksumExt;
	} else {
	    $cksum_ref = \&CksumInt;
	}
    }

    # compute checksum
    if ($fi->size >= 1000) {
	# File size over 1k - experiments show that about where it cheaper
	# to fork a binary check.
	$sum = CksumExt($path);
    } else {
	$sum = $cksum_ref->($path);
    }
    Debug("computed and saving cksum for $path ($sum)");

    SetCksum($path, $sum, $fi->mtime);
    return $sum;
}

sub CksumInt($) {
    my ($path) = @_;
    my $fh = new IO::File;
    open($fh, $path) or die $!;
    binmode($fh);
    my $sum = String::CRC::Cksum::cksum($fh);
    close($fh) or die $!;
    return $sum;
}

sub CksumExt($) {
    my ($path) = @_;
    my $fh = new IO::File;
    open($fh, "cksum \Q$path\E|") or die $!;
    my $line = <$fh>;
    my ($sum) = split(' ', $line);
    close($fh) or die $!;
    return $sum;
}

# Store file info in cache - for dryrun results
# !!! need to store this in session file so it works across processes?

sub SetFileInfo($$) {
    my ($path, $info) = @_;
    $file_info{$path} = $info;
}

sub GetFileInfo($) {
    my ($path) = @_;

    return $file_info{$path} if (defined $file_info{$path});
    my $info = new Cf::FileInfo;
    my @st = lstat($path);
    if (!@st) {
	$info->type('NONE');
	return $info
    }

    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	  $atime,$mtime,$ctime,$blksize,$blocks) = @st;

    $info->dev($dev);
    $info->ino($ino);
    $info->nlink($nlink);
    $info->uid($uid);
    $info->gid($gid);
    $info->size($size);
    $info->atime($atime);
    $info->mtime($mtime);
    $info->ctime($ctime);

    $info->perm($mode & 07777);
    if (-l _) {
	$info->type('LINK');
    } elsif ( -f _ ) {
	$info->type('FILE');
    } elsif ( -d _ ) {
	$info->type('DIR');
    } else {
	$info->type('SPECIAL');
    }

    return $info
}

sub fileinfo {
    my ($o, $path) = get_options(\%parse_opt, @_);
    $path = FollowLinks($path) if $o->{FOLLOW_LINKS};
    return GetFileInfo($path);
}
push(@EXPORT, '&fileinfo');
# string_op('fileinfo'); ?? if i add attr query arg?

# Convert glob pattern to corresponding regular expression.
sub glob2pat {
    my $globstr = shift;
    my %patmap = (
	'%' => '.*',
	'*' => '[^/]*',
	'?' => '[^/]',
	'[' => '[',
	']' => ']',
	'-' => '-',
    );
    $globstr =~ s{(.)} { $patmap{$1} || "\Q$1" }ge;
    return '^' . $globstr . '$';
}
push(@EXPORT, '&glob2pat');
string_op('glob2pat');

# Pattern matching flags for file include/exclude lists
my $EX_FULLPATH = 1;	# Match against full path (default is to just match
			# against the base file name)?
my $EX_INCLUDE = 2;	# Include matching paths (default is to exclude)?

# Generate match item for glob pattern - if the pattern contains a / then
# adds the fullpath matching flag automatically.
sub GlobMatch($$) {
    my ($glob,$flags) = @_;
    $flags |= $EX_FULLPATH if ($glob =~ m{/});
    return ($flags, glob2pat($glob));
}

# Generate a match item that excludes files matching a glob pattern.
sub ExGlob($) { return GlobMatch($_[0], 0) }

# Generate a match item that includes files matching a glob pattern.
sub InGlob($) { return GlobMatch($_[0], $EX_INCLUDE) }

# Check if file path is excluded by a match list. The match list is a
# (reference to) a list of alternating match flags (see $EX_* values defined
# above) and regular expression patterns.

sub IsExcluded($$;$) {
    my ($matches_ref, $path, $default)  = @_;
    $default = 0 if !defined $default;
    my $base = basename($path);

    my $len = @{$matches_ref};
    for (my $i=0; $i < $len; $i += 2) {
	my $flags = @{$matches_ref}[$i];
	my $re = @{$matches_ref}[$i+1];

	my $match;
	if ($flags & $EX_FULLPATH) {
	    $match = $path =~ /$re/;
	} else {
	    $match = $base =~ /$re/;
	}
	if ($match) {
	    my $result = ($flags & $EX_INCLUDE) ? 0 : 1;
	    Debug($result ? "excluding $path" : "including $path");
	    return $result;
	}
    }
    # No match - return default.
    return $default;
}

# IsExcluded2 options-reference path [default]
sub IsExcluded2($$;$) {
    my ($optref, $path, $default)  = @_;
    $path = Decode($path) if $optref->{REMOTE_SRC};
    return IsExcluded($optref->{EXCLUDE}, $path, $default);
}

# Given system ticks of an event return how many days ago it happened.

my $secs_per_day = 60*60*24;
sub Age($) {
    my ($when) = @_;
    return ((time() - $when)/$secs_per_day);
}

#----------------------------------------------------------------------
# (safe) System modifying routines.

sub CheckFile($%) {
    my ($path, %opts) = @_;

    if ($opts{EXCLUDE} && IsExcluded($opts{EXCLUDE}, $path)) {
	# Excluded from checks - never mind.
	return;
    }
    my $fi = GetFileInfo($path);

    # Define target location - to be used for relative perm specification.
    # If no target is specified or the target does not exist use the temp
    # file for relative perm calculation instead.
    my $target = $opts{TARGETPATH};
    if ( !defined $opts{TARGETPATH} || !-e $opts{TARGETPATH} ) {
	$target = $path;
    }

    if ($fi->type eq 'LINK') {
	# Nothing to do if not traversing links (we don't check perms on
	# (soft) links as they don't matter)
	return if !$opts{FOLLOW_LINKS};

	$path = FollowLinks($path);
	$fi = GetFileInfo($path);
    }

    if ($fi->type eq 'NONE') {
	# File does not exist
	# !!! ignoring in dryrun mode ... ideally should keep track of
	# created files and would verify that prior step would have created
	# the file.
	return if $opts{SKIP_MISSING} or !$update;
	die "file does not exist: $path";
    }

    Debug("checking $path");

    if (defined $opts{'OWNER'}) {
	# check owner of file

	my $user = $opts{'OWNER'};
	my $uid;

	if ( $user =~ /^[0-9]+$/ ) {
	    # User specified as uid.

	    $uid = $user;
	} else {
	    # Assume user specified by name - look up id.
	    # Lookup allowed to fail in nonupdate mode - assume that user
	    # would have been created in an earlier step.

	    my @fields = getpwnam($user);
	    die "user $user unknown" unless (@fields || (!$update));
	    $uid = $fields[2];
	}
	Debug("checking $path owner is $user ($uid), old is " . $fi->uid);
	if ($uid != $fi->uid) {
	    MarkChange("setting owner of $path to $user");
	    if ($update) {
		Undo("fix", $path, -user=> $fi->uid);
		chown($uid, -1, $path) or die $!;
		$fi = GetFileInfo($path);
	    }
	}
    }
    if (defined $opts{'GROUP'}) {
	# check group of file

	my $group = $opts{'GROUP'};
	my $gid;

	if ( $group =~ /^[0-9]+$/ ) {
	    # User specified as gid.

	    $gid = $group;
	} else {
	    # Assume group specified by name - look up id.
	    # Lookup allowed to fail in nonupdate mode - assume group
	    # would have been created in an earlier step.

	    my @fields = getgrnam($group);
	    die "group $group unknown" unless (@fields or (!$update));
	    $gid = $fields[2];
	}
	Debug("checking $path group is $group ($gid), old is " . $fi->gid);
	if ($gid != $fi->gid) {
	    MarkChange("setting group of $path to $group");
	    if ($update) {
		Undo("fix", $path, -group=> $fi->gid);
		chown(-1, $gid, $path) or die $!;
		$fi = GetFileInfo($path);
	    }
	}
    }
    #!!! collapse the two chown() calls into one if possible?
    
    my $mode = $opts{'MODE'};
    if ($fi->type eq 'DIR') {
	$mode = $opts{'DIRMODE'} if defined $opts{'DIRMODE'};
    }

    if ($mode) {
	# check mode (permissions) of file

	if ($mode =~ /^\d/) {
	    # Numeric mode. Convert from octal if it has a leading 0.
	    $mode = oct($mode) if $mode =~ /^0/;
	} else {
	    # Symbolic mode.
	    require File::chmod;

	    # If DEBUG is on then includes bogus permission validation - so
	    # disable (on by default)
	    $File::chmod::DEBUG = 0;
	    $File::chmod::UMASK = 0;

	    Debug("applying $mode to $target (",
		    sprintf("%04o", GetFileInfo($target)->perm), ")");
	    ($mode) = File::chmod::getchmod($mode, $target);
	}
	my $mode_str = sprintf("%04o", $mode);
	Debug("checking $path mode is $mode_str");
	if ($mode != ($fi->perm) ) {
	    MarkChange("setting mode of $path to $mode_str");
	    if ($update) {
		Undo("fix", $path, -mode=> $fi->perm);
		chmod($mode, $path) or die $!;
	    }
	}
    }

    # Check children if this is a directory and recursion was requested.

    if ($fi->type eq 'DIR' && $opts{'RECURSE'} ) {
	$opts{'RECURSE'}--;
	my @args = %opts;
	foreach my $file ( ReadDir($path) ) {
	    CheckFile("$path/$file", @args);
	}
    }
}

sub RemoveFile {
    my ($path, %opts) = @_;

    my $fi = GetFileInfo($path);
    return if ($fi->type eq 'NONE');

    MarkChange("removing $path");

    return unless ($update);

    Backup($path, %opts);
    RealRemoveTree($path);
}

sub CopyFile {
    my ($srcpath, $destpath, %opts) = @_;
    my $compare = $opts{COPY_TYPE} || uc($flags{COPY_TYPE});
    my $verify = $opts{VERIFY} || uc($flags{VERIFY});
    my $newtime = $opts{NEW_TIME};
    $newtime = $flags{NEW_TIME} unless defined $newtime;

    if ($compare eq "HARDLINK" || $compare eq "SOFTLINK") {
	foreach my $optname ("OWNER", "GROUP", "MODE",
		    "REMOTE_SRC", "REMOTE_DEST", ) {
	    if (defined $opts{$optname}) {
		die "can't use option $optname with copy-type $compare\n";
	    }
	}
    }

    if ($compare eq "SOFTLINK") {
	# !!! should we offer option to create relative path link?
	MakeLink(AbsolutePath($srcpath), $destpath, %opts);
	return;
    }
    if ($compare eq "HARDLINK") {
	HardLink($srcpath, $destpath, %opts);
	return;
    }

    die "can't use binary comparison for remote copy\n"
	    if ($opts{REMOTE_SRC} || $opts{REMOTE_DEST})
		&& ($compare eq 'BINARY' || $verify eq 'BINARY');
    die "source and destination are remote\n"
	    if ($opts{REMOTE_SRC} && $opts{REMOTE_DEST});

    my $si = GetFileInfo($srcpath);
    my $di = GetFileInfo($destpath);

    if (defined $di->dev
		&& $si->dev == $di->dev
		&& $si->ino == $di->ino) {
	debug("no copy, files are hard linked: $srcpath and $destpath");
	return;
    }

    if (!defined $opts{MODE}) {
	# Mode not explicity set for copy - use source permissions but apply
	# umask.
	$opts{MODE} = ($si->perm & ~umask());
    }

    # Grab source checksum is already computed
    my $cksum = $si->cksum;

    # Check if source and destination differ - first compare file sizes for
    # a real quick check.

    my $same = ( $di && $si->size == $di->size );
    if ($same) {
	if ( $compare eq 'MD5' ) {
	    $same = (MD5($srcpath) eq MD5($destpath));
	} elsif ( $compare eq 'CKSUM' ) {
	    # Make sure we have the source checksum
	    $cksum = Cksum($srcpath) unless defined $cksum;
	    $same = ($cksum eq Cksum($destpath));
	} elsif ( $compare eq 'MTIME' ) {
	    if ($newtime) {
		$same = ($si->mtime < $di->mtime);
	    } else {
		$same = ($si->mtime == $di->mtime);
	    }
	} elsif ( $compare eq 'BINARY' ) {
	    $same = (compare($srcpath, $destpath) == 0);
	} else {
	    die "unknown comparison method: $compare";
	}
    }

    if ($same) {
	# File content matches, make sure options match then return.
	# Override RECURSE option - want just this file checke even if copy
	# is recursive.
	# Override EXCLUDE option - meant for source path, not dest (and
	# already checked).
	# !!! - should we explicitly pass the opts we want, instead of
	# blanking the ones we dont?
	CheckFile($destpath, %opts, EXCLUDE=>undef, RECURSE => 0)
		if (scalar(%opts));
	return;
    }

    MarkChange("copying $srcpath to $destpath");
    if (!$update) {
	# Not really copying - fake it.

	# No faking available for remote destinations.
	return if ($opts{REMOTE_DEST});

	if ($opts{REMOTE_SRC}) {
	    Geturl($srcpath, MakeFake($destpath));
	} else {
	    SetFake($destpath, $srcpath);
	}
	return
    }

    if ($opts{REMOTE_DEST}) {
	# Copying to remote location.
	my @args = ();
	push(@args, $si->mtime) unless $newtime;
	SendPut($opts{REMOTE_DEST}, $destpath, RawReadFile($srcpath), @args);
	return;
    }
    # Destination is local

    MakeParent($destpath);

    # Safe copy (copy to temp and then move into place)
    my $temp = TempName($destpath, %opts);

    eval {
	if ($opts{REMOTE_SRC}) {
	    Geturl($srcpath, $temp);
	} else {
	    File::Copy::copy($srcpath, $temp)
		or die "can't copy from $srcpath: $!\n";
	}
    };
    if (my $err = $@) {
	unlink($temp);
	die $err;
    }

    unless ($newtime) {
	my $mtime = $si->mtime;
	utime(time(), $mtime, $temp) or die "can't set time on $temp";
    }

    # verify copy - always verify size, optionally validate content.
    my $ti = GetFileInfo($temp);
    die "size changed during copy of $srcpath"
	    unless $ti->size == $si->size;
    if ($verify ne 'NONE') {
	# verify content
	my $same;
	if ( $verify eq 'MD5' ) {
	    $same = (MD5($srcpath) eq MD5($temp));
	} elsif ( $verify eq 'CKSUM' ) {
	    $same = (Cksum($srcpath) eq Cksum($temp));
	} elsif ( $verify eq 'BINARY' ) {
	    $same = (compare($srcpath, $temp) == 0);
	} else {
	    die "unknown verification method: $verify";
	}
	die "$srcpath changed during copy" unless $same;
    }

    # Override RECURSE option - want just this file checke even if copy
    # is recursive.
    # Override EXCLUDE option - meant for source path, not dest (and
    # already checked).
    # !!! - should we explicitly pass the opts we want, instead of
    # blanking the ones we dont?
    MoveTemp($temp, $destpath, %opts, EXCLUDE=>undef, RECURSE => 0);

    # Update checksum database
    SetCksum($destpath, $cksum, $ti->mtime);
}

# Set modification time of file to now (create file if necessary).

sub TouchFile($%) {
    my ($file, %opts) = @_;
    if (-e $file) {
	# File exists, update mtime.
	MarkChange("touching $file");
	return if (!$update);

	my $now = time;
	utime($now, $now, $file) or die $!;
	CheckFile($file, %opts) if (scalar(%opts));
    } else {
	# No file, create empty one.
	WriteFile($file, "", %opts);
    }
}

# Get path for storing dry-run contents of file.

sub GetFake($) {
    my ($path) = @_;

    # See if we have a fake copy of file in session files.
    my $fake = GetSession()."/fake".AbsolutePath($path);
    if (-f $fake) {
	return $fake;
    }

    # See if we have pointer to fake copy of file.
    $fake = GetSession()."/fakepath".AbsolutePath($path);
    if (-f $fake) {
	return RawReadFile($fake);
    }

    return $path;
}

# Get path for storing dry-run contents of file.

sub MakeFake($) {
    my ($path) = @_;

    my $fake = GetSession()."/fake".AbsolutePath($path);
    RealMakeDir(dirname($fake));
    Debug("new fake path for $path: $fake");
    return $fake;
}

# Define alternate path that holds contents of file for dry-run (would have
# copied $fake to $path).

sub SetFake($$) {
    my ($path, $fake) = @_;
    Debug("new fake path for $path: $fake");
    my $fakefile = GetSession()."/fakepath".AbsolutePath($path);
    RealWriteFile($fakefile, $fake);
}

# Create/replace $filename with data in $content - appends a newline.

sub WriteFile {
    my ($destpath, $content, %opts) = @_;

    $destpath = FollowLinks($destpath) if $opts{FOLLOW_LINKS};

    # If contents already matches just check file attributes.
    # Need to fudge the quick size check by 1 as read/write may add/remove a
    # final newline.
    my $fi = GetFileInfo($destpath);
    if ( $fi->exist() && (abs($fi->size - length($content)) <= 1) ) {

	my $oldcontent = ReadFile($destpath);
	if ($content eq $oldcontent) {
	    CheckFile($destpath, %opts) if (scalar(%opts));
	    return;
	}
    }

    MarkChange("writing $destpath");
    if (!$update) {
	RealWriteFile(MakeFake($destpath),$content);
	return
    }

    MakeParent($destpath);
    my $temp = TempName($destpath, %opts);
    RealWriteFile($temp,$content);
    MoveTemp($temp, $destpath, %opts);
}

# Create a symbolic link

sub MakeLink {
    my ($src, $dest, %opts) = @_;

    my $desttype = CheckType($dest, 'LINK', %opts);
    Debug("$dest is $desttype");
    if ($desttype eq 'LINK') {
	return if (ReadLink($dest) eq $src);
    }

    MarkChange("linking $dest -> $src");

    # Just print?
    return unless ($update);

    MakeParent($dest);
    my $temp = TempName($dest, %opts);
    symlink($src, $temp) or die $!;
    MoveTemp($temp, $dest, %opts);
}

# Create a hard link

sub HardLink {
    my ($src, $dest, %opts) = @_;

    my $desttype = CheckType($dest, 'FILE', %opts);
    Debug("$dest is $desttype");

    my $srcinfo = GetFileInfo($src);
    my $destinfo = GetFileInfo($dest);

    # See if its possible to hard link these locations
    # If dest does not exist, find first parent directory that exists.
    # Verify that this destination location and the source share the same
    # device.
    my $path = $dest;
    my $info = $destinfo;
    while ($info->type eq "NONE") {
	$path = dirname($path);
	$info = GetFileInfo($path);
    }
    if ($srcinfo->dev != $info->dev) {
	die "can't link $src and $dest - different devices\n";
    }

    # Check if already linked
    return if ($srcinfo->ino == $destinfo->ino);

    MarkChange("hard linking $dest -> $src");

    if (!$update) {
	# Fake out destination file info - set it to source's, but dont make
	# any changes
	SetFileInfo($dest, $srcinfo);
	return;
    }

    # Create the link.
    MakeParent($dest);
    my $temp = TempName($dest, %opts);
    link($src, $temp) or die $!;
    MoveTemp($temp, $dest, %opts);
}

# Synchronize contents of two directories.

sub DirSync {
    my ($srcdir, $destdir, @args) = @_;
    my %opts = @args;
    my %src_exists = ();

    foreach my $file ( ReadDir($srcdir) ) {
	my $destfile = $file;

	# Translate filename to/from url
	if ($opts{REMOTE_SRC}) {
	    $destfile = Decode($destfile);
	}
	if ($opts{REMOTE_DEST}) {
	    $destfile = Encode($destfile);
	}

	FileSync("$srcdir/$file", "$destdir/$destfile", @args);
	$src_exists{$destfile} = 1;
    }

    if ($opts{'PURGE'}) {
	# Remove extraneous files from destination.

	# Not updating so target may not exist
	# !!! this guard is unnecessary if we start faking file info in dry
	# run more.
	if (!$update && GetFileInfo($destdir)->type eq 'NONE') {
	    return;
	}

	# Exluding patterns from purge?
	my $excluding = $opts{EXCLUDE} && ($opts{PURGE} ne 'EXCLUDED');

	foreach my $file ( ReadDir($destdir) ) {
	    if ( !$src_exists{$file} ) {
		my $path = "$destdir/$file";
		unless ($excluding && IsExcluded2(\%opts, "$srcdir/$file")) {
		    RemoveFile($path, @args);
		}
	    }
	}
    }
}

# Dereference link (recursively) to get to the real target.

sub FollowLinks($) {
    my ($target) = @_;
    
    my $count = 0;
    my $path = $target;
    while (GetFileInfo($path)->type eq 'LINK') {
	die "too many links (loop?): $target\n" if ($count++ == $max_links);
	my $newpath = ReadLink($path) or die $!;
	$path = AbsolutePath($newpath, dirname($path))
    }
    return $path;
}

# Ensure path is a directory with specified settings.

sub MakeDir {
    my ($path, %opts) = @_;

    $path = FollowLinks($path) if $opts{FOLLOW_LINKS};

    my $oldtype = CheckType($path, 'DIR', %opts);
    if ($oldtype eq 'DIR') {
	# Directory already exists, make sure options match then return.
	CheckFile($path, %opts, RECURSE => 0) if (scalar(%opts));
	return;
    }

    MarkChange("creating directory $path");

    # Just print?
    return unless ($update);

    my $temp = TempName($path, %opts);
    RealMakeDir($temp);
    MoveTemp($temp, $path, %opts);
}

# Ensure parent directory for specified path exists

sub MakeParent($) {
    my ($path) = @_;
    my $parent = dirname($path);

    # Create the parent - dont break any existing links
    MakeDir($parent, FOLLOW_LINKS=>1);
}

#----------------------------------------------------------------------
# Simple network encoding
# Basically URL encoding? (but don't want dependency on full URL module).

my %char2hex = ();
my %hex2char = ();
foreach my $byte (0 .. 255) {
    my $char = sprintf("%c", $byte);
    my $hex = sprintf("%02x", $byte);
    $char2hex{$char} = $hex;
    $hex2char{$hex} = $char;
}
sub Encode($) {
    my ($str) = @_;
    $str =~ s/[^\w-\/\.]/%$char2hex{$&}/g;
    return $str;
}
sub Decode($) {
    my ($str) = @_;
    $str =~ s/%(..)/$hex2char{$1}/g;
    return $str;
}

#----------------------------------------------------------------------
# External routines (exported to scripts)

# Retrieve document from URL.

sub geturl {
    my ($optref, $url, $dest) = get_options({}, @_);
    my $argslen = @_;
    if ($argslen < 1 || $argslen > 2) {
	die "geturl takes 1-2 arguments, not $argslen\n";
    }
    
    if (!defined $dest) {
	# No target file - simply return contents to calling routine.
	return Geturl($url);
    }

    # Sending URL contents to file
    my $origdest = $dest;

    # Get modtime of destination - to determine if we need a new copy
    my $mtime = fileinfo($origdest)->mtime;

    if (!$update) {
	# Not really updating. Get a fake destination path.
	$dest = MakeFake($origdest);
    }

    MakeParent($dest);
    my $temp = TempName($dest, %{$optref});
    if (defined $mtime) {
	# Destination exists - set temp file mtime so Geturl can
	# use If-Modified-Since appropriately
	RealWriteFile($temp, "");
	utime(time(), $mtime, $temp) or die $!;
    }

    my $code = Geturl($url, $temp);
    if ($code == "304") {
	# URL is not modified
	debug("url is not modified: $url");
	unlink($temp);
    } else {
	MarkChange("copying $url to $origdest");
	MoveTemp($temp, $dest, %{$optref});
    }

    return $code;
}
push(@EXPORT, '&geturl');
string_op("geturl");

# Retrieve document from URL - if destination specified then write to that
# file (always - does not follow safe rules). Otherwise return document to
# caller. Throws an exception if the document cannot be retrieved.

my $geturl_ref;
my $gethttp_ref;
my $lwp_ua;
sub Geturl($;$) {
    my ($url, $dest) = @_;

    if (not defined $geturl_ref) {
	eval { require HTTP::Lite; };
	$gethttp_ref = \&GeturlLite unless ($@);

	eval {
	    require LWP::UserAgent;
	    require HTML::HeadParser;	# Some boxes are missing this module
	    				# which causes LWP to fail later.
	};
	if ($@) {
	    # No LWP - fall back to curl
	    $geturl_ref = \&GeturlCurl;
	} else {
	    # Have LWP - use it for all urls
	    $geturl_ref = \&GeturlLwp;
	    $gethttp_ref = $geturl_ref;
	    $lwp_ua = LWP::UserAgent->new(keep_alive=>2);
	}
    }
    if ($url =~ /^file:/) {
	return GeturlFile($url, $dest);
    } elsif ($gethttp_ref && $url =~ /^http:/) {
	return $gethttp_ref->($url, $dest);
    } else {
	return $geturl_ref->($url, $dest);
    }
}

sub GeturlFile($;$) {
    my ($url, $dest) = @_;
    Debug("downloading $url (file)");
    my ($host, $path) = ($url =~ m{^file://([^/]*)(.*)});
    die "bad url: $url\n" unless $path;

    if (defined $dest) {
	# copy file
	# !!! Not convergent - should be checking if they are the same.
	File::Copy::copy($path, $dest)
		or "failed to copy $path to $dest: $!\n";
	return "200";
    } else {
	# read file to memory
	return RawReadFile($path);
    }
}

sub GeturlLite($;$) {
    my ($url, $dest) = @_;
    Debug("downloading $url (lite)");

    my $http = new HTTP::Lite;
    my @args = ();
    my $fh;
    if (defined $dest) {
	$fh = new IO::File;
	open($fh, ">$dest") or die "can't write to $dest: $!\n";
	push(@args, \&GeturlLiteCallback, $fh);
    }
    my $req = $http->request($url, @args)
	    or die "failed to get $url: $!\n";
    die "failed to get $url ($req): ".$http->status_message()
	    if $req ne "200";

    if (defined $dest) {
	close($fh) or die $!;
	return $req;
    } else {
	return $http->body();
    }
}

sub GeturlLiteCallback {
    my ($self,$dataref,$cbargs) = @_;
    print $cbargs $$dataref;
    return undef;
}

sub GeturlLwp($;$) {
    my ($url, $dest) = @_;
    Debug("downloading $url (lwp)");
    my $res;
    my $rv;
    if (defined $dest) {
	$res = $lwp_ua->mirror($url, $dest);
	$rv = $res->code;
    } else {
	my $req = HTTP::Request->new(GET => $url);
	$res = $lwp_ua->request($req);
	$rv = $res->content;
    }
    die "failed to get $url: ".$res->status_line()."\n" if $res->is_error();
    return $rv;
}


sub GeturlCurl($;$) {
    my ($url, $dest) = @_;
    my $command = "curl -fsS $url";

    Debug("curling $url");

    # Could do just - but that allows the shell to invade:
    #my $pid = open(PIPE, "$command|");

    my $pid = open(PIPE, "-|");
    if ($pid == 0) {
	# child
	exec('curl', '-fsS', $url) or die "can't exec curl: $!";
	# NOTREACHED
    }
    # Parent

    die "command ($command) failed: $!" unless $pid;

    my $buffer = '';
    my $bufsize = 8*1024;
    my $content = '';
    if (defined $dest) {
	# Direct content to file.
	open(OUT, ">$dest") or die "can't write to $dest: $!";
	while (sysread(PIPE, $buffer, $bufsize)) {
	    print OUT $buffer or die $!;
	}
	close(OUT) or die $!;
    } else {
	# Capture content to return to caller.
	while (sysread(PIPE, $buffer, $bufsize)) {
	    $content .= $buffer;
	}
    }

    close(PIPE) or die "command ($command) failed: $!";
    return $content unless defined $dest;
}

# Generated table of contents for specified directory tree so that it can be
# used as the source for rcopy.

sub MakeTOC($$$%) {
    my ($dir, $fieldsref, $write_index, %opts) = @_;
    my $header = "# cftoc 1.0";
    $dir = AbsolutePath($dir);
    my @lines = ();
    my %dirlines = ();

    sub TocEntry {
	my $basename = $_;
	return if $basename eq '.cftoc';

	my $relpath = $File::Find::name;
	my $dirpath = $File::Find::dir;
	# Trim off leading "." when joining with relative path
	my $path = $dir . substr($relpath, 1);
	my $fi = GetFileInfo($basename);
	my @opts = ();

	if ($fi->type eq 'DIR') {
	    my $toc = "$header\n";;
	    if (defined $dirlines{$relpath}) {
		$toc .= join("\n", @{$dirlines{$relpath}});
		delete $dirlines{$relpath};
	    }
	    WriteFile("$path/.cftoc", $toc, %opts) if $write_index;
	}

	# Try to convert user and group ids to names.
	my $user = $fi->uid;
	if (my @ufields = getpwuid($user)) {
	    $user = $ufields[0];
	}
	my $group = $fi->gid;
	if (my @gfields = getgrgid($group)) {
	    $group = $gfields[0];
	}

	if ($fi->type eq 'LINK') {
	    push(@opts, "link=".Encode(ReadLink($path)));
	}
	if ($fi->type eq 'FILE') {
	    if ($fieldsref->{CKSUM}) {
		push(@opts, "cksum=".Cksum($path));
	    }
	    if ($fieldsref->{MD5}) {
		push(@opts, "md5=".Encode(MD5($path)));
	    }
	}

	my $attrs = join(' ',
		$fi->type,
		$fi->size,
		$fi->mtime,
		$fi->perm,
		$user,
		$group,
		@opts);
	push(@lines, (Encode($relpath).' '.$attrs));
	push(@{$dirlines{$dirpath}}, (Encode($basename).' '.$attrs));
    }

    if (-d $dir) {
	my $wd = cwd();
	chdir($dir) or die "can't chdir to $dir: $!\n";
	finddepth({wanted =>\&TocEntry}, '.');
	chdir($wd) or die "can't chdir to $wd: $!\n";
    }

    # Write master in reverse order to convert depth-first search to
    # breadth-first (so that directories precede their children).
    my $toc = join("\n", $header, reverse(@lines));
    if ($write_index) {
	WriteFile("$dir.toc", $toc, %opts);
    } else {
	return $toc;
    }
}

# Load single directory table-of-contents into file info cache.

sub LoadDirTOC($) {
    my ($url) = @_;
    my $toc = Geturl("$url/.cftoc");

    my $fi = GetFileInfo($url);
    $fi->dir([]) if ($fi);
    LoadTOC($url, $toc, 0);
}

# Load directory tree table-of-contents into file info cache.

sub LoadTreeTOC($) {
    my ($url) = @_;

    my $toc = Geturl("$url.toc");
    LoadTOC($url, $toc, 1);
}

# !!! purge TOC entries from info cache once sync is complete?

sub LoadTOC($$$) {
    my ($url, $toc, $recursive) = @_;

    # !!! Check signature?

    die "unknown directory format for $url\n"
	    unless $toc =~ /^# cftoc 1.0/;

    # Load directory into file info cache

    my $count = 0;
    foreach my $line (split("\n", $toc)) {
	next if $line =~ /^#/;
	next if $line =~ /^\s*$/;
	my ($epath, $type, $size, $mtime, $perm, $user, $group, @opts)
		= split(' ', $line);

	my $path = Decode($epath);
	# Re-encode to get canonical encoding.
	my $repath = Encode($path);

	# Concatenate path with url, but get rid of any "." in the middle.
	my $fullpath;
	if ($path eq '.') {
	    $fullpath = $url;
	} elsif ($path =~ m{^\./}) {
	    $fullpath = $url . Encode(substr($path, 1));
	} else {
	    $fullpath = "$url/$repath";
	}

	my $fi = new Cf::FileInfo;
	$fi->type($type);
	$fi->size($size);
	$fi->mtime($mtime);
	$fi->perm($perm);

	my @ufields = getpwnam($user);
	$fi->uid($ufields[2]) if (@ufields);
	my @gfields = getgrnam($group);
	$fi->gid($gfields[2]) if (@gfields);

	if ($recursive && $type eq 'DIR') {
	    $fi->dir([]);
	}

	# Add optional file attributes that we understand.
	foreach my $opt (@opts) {
	    my ($key, $val) = split('=', $opt, 2);
	    if ($key eq 'link') {
		$fi->linkdest(Decode($val));
	    } elsif ($key eq 'cksum') {
		$fi->cksum($val);
	    } elsif ($key eq 'md5') {
		$fi->md5($val);
	    }
	}

	$file_info{$fullpath} = $fi;
	#Debug("added TOC entry for $fullpath");
	$count++;

	# Append this item to the parent's directory listing.
	my $dir = dirname($fullpath);
	if (defined $file_info{$dir}) {
            # Parent directory is in cache - append this item to the
            # parent's directory listing.
            push(@{$file_info{$dir}->dir}, basename($repath));
        }
    }
    Debug("loaded toc for $url, $count entries");
}

# Remove matching files.

sub Tidy ($%) {
    my ($path, %opts) = @_;

    Debug("tidying $path");

    my $fi = GetFileInfo($path);
    my $newpath = $path;
    if ($fi->type eq 'LINK' && $opts{FOLLOW_LINKS}) {
	$newpath = FollowLinks($path);
	$fi = GetFileInfo($newpath);
    }
    my $ftype = $fi->type;
    return if ($ftype eq 'NONE');

    my $excluded = 0;
    if ($opts{EXCLUDE}) {
	# If explicitly excluded skip this path and any children - if simply
	# doesn't match any pattern then exclude this path from tidy but
	# consider children.
	$excluded = IsExcluded($opts{EXCLUDE}, $path, 2);
	return if $excluded == 1;
    }

    unless ($excluded
	    || $opts{ATIME} && Age($fi->atime) < $opts{ATIME}
	    || $opts{CTIME} && Age($fi->ctime) < $opts{CTIME}
	    || $opts{MTIME} && Age($fi->mtime) < $opts{MTIME}
	    ) {
	# File matches criteria
	if ($ftype ne 'DIR' || $opts{RMDIR}) {
	    # File is not a directory, or directory removal is allowed.
	    eval { RemoveFile($path, %opts); };
	    if (my $err = $@) {
		Fail($opts{ONFAIL}, $err);
	    }
	    return;
	}
    }

    if ($ftype eq 'DIR') {
	# Check children.
	if ( $opts{'RECURSE'} ) {
	    $opts{'RECURSE'}--;
	    foreach my $file ( ReadDir($path) ) {
		Tidy("$path/$file", %opts);
	    }
	}
    }
}

# Make sure file contains specified line - replacing any lines that matches
# specified pattern.

sub SetLine($$$%) {
    my ($path, $pattern, $line, %opts) = @_;

    my $orig = ReadFile($path);
    my $new = StrSetLine($orig, $pattern, $line, $path, $opts{PREPEND});
    WriteFile($path, $new, %opts) if defined $new;
}

sub setline {
    my ($optref, $path, $pattern, $line) = get_options(\%parse_opt, @_);
    SetLine($path, $pattern, $line, %{$optref});
}
push(@EXPORT, '&setline');

sub StrSetLine($$$$;$) {
    my ($str, $pattern, $line, $src, $prepend) = @_;

    die "desired line ($line) does not match pattern ($pattern)\n"
	    unless $line =~ $pattern;

    # Make sure pattern will match an entire line - so we can use it to
    # substitute in the new line
    $pattern .= '.*' unless (substr($pattern, -1, 1) eq '$');
    $pattern = ".*$pattern" unless (substr($pattern, 0, 1) eq '^');

    Debug("check that $src has $line (pattern=$pattern)");

    my $new = $str;
    my $subs = ($new =~ s/$pattern/$line/mg);
    if ($subs == 0) {
	if ($prepend) {
	    $new = "$line\n" . $new;
	} else {
	    $new .= "\n" . $line;
	}
	MarkChange("adding $line in $src");
    } elsif ($subs == 1) {
	MarkChange("changing $pattern to $line in $src") unless ($new eq $str);
    } else {
	die "setline failed: $subs lines matched $pattern in $src\n";
    }
    return $new;
}
sub str_setline {
    my ($optref, $str, $pattern, $line, $src) = get_options({}, @_);
    return StrSetLine($str, $pattern, $line, $src);
}
push(@EXPORT, '&str_setline');

# Delete lines that match a specified pattern.

sub DeleteLines($$%) {
    my ($path, $pattern, %opts) = @_;

    Debug("deleting lines in $path matching ($pattern)");

    my $orig = ReadFile($path);
    my $new = StrDeleteLines($orig, $pattern, $path);
    WriteFile($path, $new, %opts) if defined $new;
}

sub deletelines {
    my ($optref, $path, $pattern) = get_options(\%parse_opt, @_);
    DeleteLines($path, $pattern, %{$optref});
}
push(@EXPORT, '&deletelines');

sub StrDeleteLines($$$) {
    my ($str, $pattern, $src) = @_;

    Debug("deleting lines matching ($pattern) in $src");

    my @origlines = split("\n", $str);
    my @newlines = grep(!/$pattern/, @origlines);

    my $delcount = @origlines - @newlines;
    return $str if ($delcount == 0);
    MarkChange("deleting $delcount line(s) that match $pattern in $src");
    my $new = join("\n", @newlines);
    if (@newlines && $str =~ /\n$/) {
	# Result is not empty, add trailing newline.
	$new .= "\n";
    }
    return $new;
}
sub str_deletelines {
    my ($optref, $str, $pattern, $src) = get_options({}, @_);
    return StrDeleteLines($str, $pattern, $src);
}
push(@EXPORT, '&str_deletelines');

# Synchronize to catalogued network volume

sub RemoteSync($$%) {
    my ($srcpath, $destpath, %opts) = @_;

    if ($srcpath =~ /^scf:/) {
    } else {
	eval { LoadTreeTOC($srcpath); };
	if (my $err = $@) {
	    LoadDirTOC(dirname($srcpath));
	}
    }

    FileSync($srcpath, $destpath, %opts, REMOTE_SRC=>1);
}

# Make $destpath have the same contents as $srcpath.

sub FileSync {
    my ($srcpath, $destpath, %opts) = @_;

    Debug("syncing $srcpath to $destpath");
    my $si = GetFileInfo($srcpath);
    if ($opts{EXCLUDE} && IsExcluded2(\%opts, $srcpath)) {
	if ($opts{PURGE} eq 'EXCLUDED') {
	    $si->type('NONE');
	} else {
	    return
	}
    }
    my $newsrcpath = $srcpath;
    if ($si->type eq 'LINK' && $opts{FOLLOW_LINKS}) {
	$newsrcpath = FollowLinks($srcpath);
	$si = GetFileInfo($newsrcpath);
    }

    my $srctype = $si->type;
    my $di = GetFileInfo($destpath);
    my $desttype = $di->type;

    if ($srctype eq 'NONE') {
	# Source does not exist
	if ($desttype ne 'NONE') {
	    # Destination does exist - are we allowed to delete it?

	    if ($opts{'PURGE'}) {
		RemoveFile($destpath, %opts);
	    } elsif (! $opts{SKIP_MISSING}) {
		die "source does not exist: $srcpath\n";
	    }
	}
	return;
    } elsif ( !$opts{CHANGE_TYPES}
	    && ($desttype ne 'NONE')
	    && ($srctype ne $desttype)
	    ) {
	die "type mismatch, $srcpath is $srctype and $destpath is $desttype";
    }

    if ($opts{REMOTE_DEST}) {
	# Target location is remote
	return if $srctype eq 'DIR';
	die "file type $srctype not supported for uploads: $srcpath"
		if $srctype ne 'FILE';
    } else {
	# Make sure parent directories of $destpath exist
	MakeParent($destpath);
    }

    if ($srctype eq 'LINK') {
	my $target = ReadLink($srcpath) or die $!;
	MakeLink($target, $destpath, %opts);

	# No need to set permissions on link - or is there!?
	return
    } elsif ($srctype eq 'DIR') {
	my $mode = $opts{DIRMODE};
	MakeDir($destpath, %opts, MODE=>$mode);
	if ( $opts{'RECURSE'} ) {
	    $opts{'RECURSE'}--;
	    DirSync($srcpath, $destpath, %opts);
	}
    } elsif ($srctype eq 'FILE') {
	CopyFile($newsrcpath, $destpath, %opts);
    } else {
	die "file type $srctype not supported: $srcpath";
    }

}

# Change user and set environment appropriately - analogous to running
# "su user".

sub BecomeUser($) {
    my ($user) = @_;

    my @ufields;
    if ( $user =~ /^[0-9]+$/ ) {
	@ufields = getpwuid($user) or die "user $user unknown";
    } else {
	@ufields = getpwnam($user) or die "user $user unknown";
    }
    my ($login, $pass, $uid, $gid, $quota, $comment, $gcos, $home, $shell)
	    = @ufields;

    # Determine all group memberships of user (to add all valid group rights
    # like the C library initgroups(3) does)
    #
    # Initialize list with two entries for default group of user - that way if
    # user has no other group member ships all root's effective group
    # memberships will be removed.

    my @groups = ($gid, $gid);
    setgrent();
    while( my ($gname, $gpasswd, $gid2, $members) = getgrent() ) {
	foreach my $member (split(' ', $members)) {
	    if ($member eq $user) {
		push(@groups, $gid2);
		last;
	    }
	}
    }

    # Set real, effective, and supplementary group access list to the
    # appropriate groups for nguser.

    ($(, $)) = ($gid, join(' ', @groups));

    # Change real and effective user ID.
    # Perl is showing its true obscure syntax here.

    ($<, $>) = ($uid, $uid);

    # Initialize environment.

    $ENV{'HOME'} = $home;
    $ENV{'LOGNAME'} = $user;
}

# Run command as specified user. Throws exception if command fails.

sub run {
    my ($optref, @args) = get_options(\%parse_opt, @_);
    my $user = $optref->{OWNER};
    my $dir = $optref->{CHDIR};
    my $timeout = $optref->{TIMEOUT} || 0;
    my $preview = $optref->{PREVIEW};
    my $sloppy_daemon = $optref->{SLOPPY_DAEMON};
    my $cmd = join(' ', @args);

    my $msg = "running";
    $msg .= " as $user" if length($user);
    MarkChange("$msg: $cmd") unless $preview;

    return unless ($update || $preview);

    PreSpawn();
    my $pid = open(PIPE, "-|");
    if (! defined $pid) {
	die "can't fork: $!";
    }
    if ($pid) {
	# This is the parent - wait for child.

	eval {
	    local $SIG{ALRM} = sub { die "timeout\n"; };
	    alarm $timeout if ($timeout > 0);

	    while (my $line = <PIPE>) {
		chomp($line);
		Info($line) if ($line =~ /\S/);
	    }
	    close(PIPE) or die $!;

	    alarm 0;
	};
	if (my $err = $@) {
	    if ($err eq "timeout\n") {
		Info("timeout: $cmd");
		kill('INT', $pid);
		# Now close - but may hang if process is wedged to use timeout
		# again.
		eval {
		    local $SIG{ALRM} = sub { die "timeout\n"; };
		    alarm $timeout if ($timeout > 0);

		    close(PIPE);

		    alarm 0;
		};
		VerifiedKill($pid)
			or Warn("can't kill timed-out command: $cmd");
		die "command timed out ($cmd)\n";
	    } else {
		close(PIPE);
		die "command failed ($cmd): $err\n";
	    }
	}
    } else {
	# This is the child.

	BecomeUser($user) if length($user);
	if (length($dir)) {
	    chdir($dir) or die "can't chdir to $dir: $!\n";
	}
	if ($sloppy_daemon) {
	    # Disconnect stdio channels
	    open(STDIN, '/dev/null') or die "can't read /dev/null: $!\n";
	    open(STDOUT, '>/dev/null') or die "can't write to /dev/null: $!\n";
	    open(STDERR, '>&STDOUT') or die "can't dup stdout: $!\n";
	}
	exec(@args) or die "cant exec: $!";
    }
}
push(@EXPORT, '&run');

# Run command and return the output. Throw error if it fails. This command
# should not have any side effects as it WILL be run in no-update mode.

sub ReadCommand($) {
    my ($command) = @_;
    my $buffer = '';
    my $maxsize = 100000;
    open(PIPE, "$command |") or die "command failed $!: $command\n";
    read(PIPE, $buffer, $maxsize);
    close(PIPE) or die "command failed $!: $command\n";
    return $buffer;
}
sub read_command {
    ReadCommand(join(' ', @_));
}
push(@EXPORT, '&read_command');

# Server-side for sync command

my %server_fields = ();
my $server_root = "$ENV{HOME}/cfsync";
my $server_writedir = "upload";

sub syncserver {
    # auto-flush output
    $| = 1;

    while (my $line = <STDIN>) {
	chomp($line);
	my @args = ();
	foreach my $arg (split(' ', $line)) {
	    push(@args, Decode($arg));
	}
	my $op = shift(@args);

	if ($op eq 'EXIT') {
	    print "200 bye\n";
	    last;
	}

	my ($result, $blob) = eval "Sync_$op(\@args);";
	if (my $err = $@) {
	    print "500 ".Encode($err)."\n";
	} elsif (defined $blob) {
	    my $len = length($blob);
	    print "201 ".Encode($result)." $len\n";
	    print $blob;
	}  else {
	    print "200 ".Encode($result)."\n";
	}
    }
}
push(@EXPORT, '&syncserver');

sub Sync_TOC {
    my ($relpath) = @_;
    my $path = $server_root;

    if (length($relpath)) {
	SyncCheckPath($relpath);
	$path .= "/$relpath";
    }
    my $toc = MakeTOC($path, \%server_fields, 0) ;
    return("OK", $toc);
}

sub SyncCheckPath($) {
    my ($relpath) = @_;
    if ($relpath !~ m{^[-\w\/\.]*$}	# Allow only alphanum and _-./
	|| "/$relpath/" =~ m{/\.\./}	# No parent directory relative
	) {
	die "illegal path: $relpath\n";
    }
}

sub Sync_GET {
    my ($relpath) = @_;
    SyncCheckPath($relpath);
    my $path = "$server_root/$relpath";

    die "not plain file: $path\n" unless -f $path;
    open(FILE, "<$path") or die "can't open $path: $!\n";
    binmode(FILE);
    my $contents = join('', <FILE>) ;
    close FILE;

    return("OK", $contents);
}

sub Sync_PUT {
    my ($relpath, $size, $mtime) = @_;

    die "uploads not allowed\n" unless -d "$server_root/$server_writedir";

    SyncCheckPath($relpath);
    die "illegal (write) path: $relpath"
	    unless $relpath =~ "^$server_writedir/";
    my $path = "$server_root/$relpath";

    my $content;
    my $actual = read(STDIN, $content, $size);
    die "only received $actual bytes (expected $size)\n" if $actual != $size;

    RealMakeDir(dirname($path));
    open(FILE, ">$path") or die "can't write to $path: $!\n";
    binmode(FILE);
    print(FILE $content) or die $!;
    close FILE;

    if (defined $mtime) {
	utime(time(), $mtime, $path) or die $!;
    }

    return("OK");
}

sub SendPut($$$;$) {
    my ($handles, $url, $content, $mtime) = @_;

    my ($relpath) = ($url =~ m{^scf://[^/]*/(.*)})
	    or die "bad put target: $url\n";
    my @args = ($relpath, length($content));
    push(@args, $mtime) if defined $mtime;
    SendCommand($handles, 'PUT', $content, @args);
}

sub SendCommand($$@) {
    my ($handles, $cmd, $upblob, @args) = @_;
    my ($rfh, $wfh) = @{$handles};

    my @encargs = ();
    foreach my $arg (@args) {
	push(@encargs, Encode($arg));
    }
    my $cmdstr = join(' ', $cmd, @encargs);
    debug("sending: $cmdstr");
    print $wfh $cmdstr, "\n";
    if (defined $upblob) {
	print $wfh $upblob;
    }
    $wfh->flush();

    my $line = <$rfh>;
    chomp($line);
    debug("  got: $line");
    my @args = ();
    foreach my $arg (split(' ', $line)) {
	push(@args, Decode($arg));
    }
    my $code = shift(@args);
    if ($code eq '500') {
	die "remote $cmd failed: $args[0]\n";
    } elsif ($code eq '200') {
	return $args[0];
    } elsif ($code eq '201') {
	my $size = $args[1];
	my $blob;
	my $actual = read($rfh, $blob, $size);
	die $! unless defined $actual;
	die "only got $actual of $size bytes" if $actual != $size;
	return $blob;
    } else {
	die "unknown result code for $cmd: $code\n";
    }
}

my %syncs = ();

sub OpenSyncServer($) {
    my ($url) = @_;

    # parse dest url
    my @opts = ();
    my ($user, $x, $server, $path) =
	    ($url =~ m{^scf://((\w)*\@)?([\w\.\-]*)/(.*)})
	    or die "bad sync url: $url\n";
    my $syncurl = "scf://";
    if ($user) {
	push(@opts, '-l', $user) if $user;
	$syncurl .= "$user\@"
    }
    $syncurl .= $server;

    return $syncs{$syncurl} if $syncs{$syncurl};

    # open connection to server
    my $rfh = new IO::File;
    my $wfh = new IO::File;
    my $pid = open2($rfh, $wfh,
	    $flags{SCF_SSH}." ".join(' ', @opts)." $server "
	    .$flags{SCF_CF}." syncserver"
	    );
    my $handles = [$rfh, $wfh];

    $syncs{$syncurl} = $handles;
    return $handles;
}

sub CloseSyncServer($) {
    my ($url) = @_;
    my $handles = $syncs{$url};

    SendCommand($handles, 'EXIT');

    my ($rfh, $wfh) = @{$handles};
    close($wfh) or die $!;
    close($rfh) or die $!;
    # !!! wait for pid ?
}

# Sync to a remote location (upload).

sub upload {
    my ($optref, $srcdir, $destdir) = get_options(\%parse_opt, @_);

    # parse dest url
    my @opts = ();
    my ($user, $x, $server, $destpath) =
	    ($destdir =~ m{^scf://((\w)*@)?([\w\.\-]*)/(.*)})
	    or die "bad push target: $destdir\n";
    push(@opts, '-l', $user) if $user;


    # open connection to server
    my $rfh = new IO::File;
    my $wfh = new IO::File;
    #open($fh, "ssh ".join(' ', @opts)." $server cf syncserver|");
    #open($fh, "ssh ".join(' ', @opts)." $server bin/cf syncserver|");
    my $pid = open2($rfh, $wfh,
	    $flags{SCF_SSH}." ".join(' ', @opts)." $server "
	    .$flags{SCF_CF}." syncserver"
	    );
    my $handles = [$rfh, $wfh];

    # Load TOC from server
    my $toc = SendCommand($handles, 'TOC', undef, $destpath);
    debug("got toc: $toc");
    LoadTOC($destdir, $toc, 1);

    DirSync($srcdir, $destdir, REMOTE_DEST=>$handles);

    SendCommand($handles, 'EXIT');
    close($wfh) or die $!;
    close($rfh) or die $!;
    #! wait for pid
}
push(@EXPORT, '&upload');

# Get name used to identify this machine's configuration. Usually the same as the
# OS hostname, but on a wildcard host this name will be the name of the wildcard
# group. By default there is no domain suffix included in this name.

my $cfhost;
sub get_host() {
    if (! defined $cfhost) {
        my $hostfile = "$vardir/host";

        # Try for find host in environment
        $cfhost = $ENV{CF_HOST};

        if (! defined $cfhost) {
            if (-f $hostfile) {
                # Not in environment but do have host saved in file
                # Need to do a "raw" read to avoid infinite loop!
                $cfhost = RawReadFile($hostfile);
            } else {
                # All else has failed - derive cfhost from OS hostname
                require Sys::Hostname;
                $cfhost = Sys::Hostname::hostname();
                $cfhost =~ s/\..*//;
            }
        }

        # Save cfhost for later runs.
        WriteFile($hostfile, $cfhost);
    }
    return $cfhost;
}
push(@EXPORT, '&get_host');
string_op('get_host');

# Get the OS hostname.
# Not sure this routine even belongs in cf, but some modules had been using get_host()
# when they really wanted the OS hostname. Added this routine to ease the conversion.
my $hostname;
sub get_hostname() {
    if (! defined $hostname) {
	require Sys::Hostname;
	$hostname = Sys::Hostname::hostname();
    }
    return $hostname;
}
push(@EXPORT, '&get_hostname');
string_op('get_hostname');

# Get uname (unix-type) - !!! depracated - should shift to getos

my $uname = $ENV{CF_UNAME};
sub get_uname() {
    if (! defined $uname) {
	$uname = `uname`;
	chomp($uname);
	$uname = 'CYGWIN' if ($uname =~ /^CYGWIN_/);

	$ENV{CF_UNAME} = $uname;
    }
    return $uname;
}
push(@EXPORT, '&get_uname');
string_op('get_uname');

# Get operating system - !!! somewhat reluctantly added - isnt their some
# standard I can be using here instead of my owm classification? (other than
# uname which does not give enough (or consistent enough) info for linux or
# windows)

my %os = split(':', $ENV{CF_OS});

sub getos {
    my ($optref, $key) = get_options(\%parse_opt, @_);
    $key = "os" unless defined $key;

    if (!%os) {
	my $class = $^O;
	my $osname = 'unknown';
	my $version = 'unknown';
	my $cpu = 'unknown';
	my $platform;
	if ($is_win) {
	    require Win32;
	    $osname = (Win32::IsWinNT()) ? 'winnt' : 'win32';
	    my ($junk, $major, $minor, $build, $id) = Win32::GetOSVersion();
	    $version = "${major}.${minor}";
	    $cpu = $ENV{'PROCESSOR_ARCHITECTURE'};
	    $platform = "win-$cpu";
	} else {
	    if ( $class eq 'linux' ) {
		my $rhat_file = '/etc/redhat-release';
		my $deb_file = '/etc/debian_version';

		if ( -f $rhat_file ) {
		    my $line = ReadFile($rhat_file);
		    $osname = 'redhat';
		    if ($line =~ /Red Hat ((Linux Advanced Server)|(Enterprise Linux.*)) release (\d[\d.]*)/) {
			$osname = 'rhel';
			$version = $4;
		    } elsif ($line =~ /Red Hat .*release (\d[\d.]*)/) {
			$version = $1;
		    } elsif ($line =~ /Fedora .*release (\d[\d.]*)/) {
			$osname = 'fedora';
			$version = $1;
		    } elsif ($line =~ /CentOS .*release (\d[\d.]*)/) {
			# Not really Redhat-Enterprise (its Centos),
			# but it is binary compatible with rhel.
			$osname = 'rhel';
			$version = $1;
		    }
		} elsif ( -f $deb_file ) {
		    $osname = 'debian';
		    $version = ReadFile($deb_file);
		}
		($cpu) = split(" ", ReadCommand("uname -m"));

		my ($majorversion) = split(/\./, $version);
		my ($cpuclass) = ReadCommand("uname -i");
		chomp($cpuclass);
		$platform = "$osname-$majorversion-$cpuclass";
	    } elsif ( $class eq 'aix' ) {
		$osname = 'aix';
		($version, $cpu) = split(" ", ReadCommand("uname -vm"));
	    } else {
		$osname = $class;
		($version, $cpu) = split(" ", ReadCommand("uname -rm"));
	    }
	}
	$os{class} = $class;
	$os{name} = $osname;
	$os{version} = $version;
	$os{cpu} = $cpu;
	$os{os} = "$osname-$version";
	$os{all} = "$osname-$version-$cpu";

	# ID for binary software type
	$os{platform} = $platform || $os{all};

	$ENV{CF_OS} = join(':', %os);
    }

    die "getos: unknown key: $key" unless defined $os{$key};
    return $os{$key};
}
push(@EXPORT, '&getos');
string_op('getos');

# Determine base of configuration script/module tree

sub GetBase() {
    return $cfbase;
}

# Get path to session state files. Create new session if one does not exist
# yet.

sub GetSession() {
    return $ENV{CF_SESSION} if (defined $ENV{CF_SESSION});

    # Create unique identifier for this session: concatenate process id and
    # current time (in seconds)
    my $now = time();
    my $sid = "$PID-$now";
    my $session = "$vardir/session/$sid";
    my $host = get_host();
    my $uname = get_uname();

    Undo("debug", "starting session $sid");

    $ENV{CF_SESSION} = $session;
    SetSession();

    RealMakeDir($session);

    # Initialize session state.
    my $changes = $change_count || 0;
    RealWriteFile($change_file, $changes);

    # !!! this script needs to be thought out more carefully!
    # what exactly are it's duties:
    # *
    RealWriteFile("$session/init.sh", <<EOF );
CF_UNAME="$uname"; export CF_UNAME
CF_SESSION="$session"; export CF_SESSION
cf_svcdir=`dirname \$0`
case \$cf_svcdir in
/*) : ;;
*) cf_svcdir="`pwd`/\$cf_svcdir"
esac
cf_host='$host'
if [ -f \$cf_svcdir/site.ini ]
then
    . \$cf_svcdir/site.ini
fi
if [ -f \$cf_svcdir/PERHOST/\$cf_host/host.ini ]
then
    . \$cf_svcdir/PERHOST/\$cf_host/host.ini
fi
EOF

    # Clean up old sessions once a day.
    my $cleanflag = "$vardir/session.cleanup";
    if (!-f $cleanflag || -M $cleanflag >= 1) {
	# Remove session files over 2 days old
	Tidy("$vardir/session",
		RECURSE=>1, MTIME=>2, BACKUP=>'NONE', RMDIR=>1);

	# Update flag
	RealWriteFile($cleanflag, "");
    }

    return $session;
}

# Define session-based globals

sub SetSession() {
    my $session = $ENV{CF_SESSION};
    $change_file = "$session/changes";
}

SetSession() if (defined $ENV{CF_SESSION});

# Clean up (flush) various things before spawning a child cf process.
sub PreSpawn() {
    # Flush log
    if (defined $logfh) {
	close($logfh) or die $!;
	$logfh = undef;
    }

    # Flush file checksums.
    UntieCksum();

    # Flush change count.
    # Only need to do this if we have an external change file and more than
    # one change has been made since the last sync with the change file
    # (first change is flushed immediately).
    if (defined $change_file && $change_count > $last_read_changes+1) {
	RealWriteFile($change_file, $change_count);
    }
    undef $change_count;
}


#----------

sub file {
    my ($optref, @files) = get_options(\%parse_opt, @_);
    foreach my $path (@files) {
	if (-e $path) {
	    CheckFile($path, %{$optref});
	} else {
	    TouchFile($path, %{$optref}) unless $optref->{SKIP_MISSING};
	}
    }
}
push(@EXPORT, '&file');

sub touch {
    my ($optref, @files) = get_options(\%parse_opt, @_);
    foreach my $path (@files) {
	TouchFile($path, %{$optref})
	    unless ($optref->{SKIP_MISSING} && !(-e $path));
    }
}
push(@EXPORT, '&touch');

sub fix {
    my ($optref, @paths) = get_options(\%parse_opt, @_);
    foreach my $path (@paths) {
	CheckFile($path, %{$optref});
    }
}
push(@EXPORT, '&fix');

sub copy {
    my ($optref, $src, $dest) = get_options(\%parse_opt, @_);
    $dest = FollowLinks($dest) if $optref->{FOLLOW_LINKS};
    FileSync($src, $dest, %{$optref});
}
push(@EXPORT, '&copy');

sub rcopy {
    my ($optref, $src, $dest) = get_options(\%parse_opt, @_);
    $dest = FollowLinks($dest) if $optref->{FOLLOW_LINKS};
    RemoteSync($src, $dest, %{$optref});
}
push(@EXPORT, '&rcopy');

sub toc {
    my ($optref, $dir) = get_options(\%parse_opt, @_);
    my %fields = ();

    if ($optref->{TOC_FIELDS}) {
	foreach my $field (@{ $optref->{TOC_FIELDS} }) {
	    $fields{$field} = 1;
	}
    }

    # Generate one log entry - not one for each index file we create.
    Info("indexing $dir");
    my $inform = $flags{INFORM};
    $flags{INFORM} = 0;

    # Generate the indexes - default to no backups.
    eval { MakeTOC($dir, \%fields, 1, BACKUP=>"NONE", %{$optref}); };
    my $err = $@;

    # Restore informational messages.
    $flags{INFORM} = $inform;

    die $err if $err;
}
push(@EXPORT, '&toc');

sub directory {
    my ($optref, @paths) = get_options(\%parse_opt, '-follow', @_);
    foreach my $path (@paths) {
	MakeDir($path, %{$optref});
    }
}
push(@EXPORT, '&directory');

# !!! I hate the name "makelink" = but link is a perl builtin
sub makelink {
    my ($optref, $src, $dest) = get_options(\%parse_opt, @_);
    MakeLink($src, $dest, %{$optref});
}
push(@EXPORT, '&makelink');

sub tidy {
    my ($optref, @paths) = get_options(\%parse_opt, @_);
    foreach my $path (@paths) {
	Tidy($path, %{$optref});
    }
}
push(@EXPORT, '&tidy');

sub writefile {
    my ($optref, $path, $content) = get_options(\%parse_opt, @_);
    WriteFile($path, $content, %{$optref});
}
push(@EXPORT, '&writefile');

sub initshellmodule {
    my ($optref, $script_path) = get_options({}, @_);

    my $dir = dirname(AbsolutePath($script_path));
    my $modname = basename($dir);
    my $session = GetSession();
    my $host = get_host();
    my %vars = 
    my %vars = (LoadVars("$dir/site.ini"), GetHostVars($modname));

    my $script = <<EOF;
CF_UNAME="$uname"; export CF_UNAME ;
CF_SESSION="$session"; export CF_SESSION ;
cf_svcdir="$dir" ;
cf_host='$host' ;
EOF
    foreach my $key (keys(%vars)) {
	$script .= "$key='$vars{$key}';\n";
    }
    return $script;
}
push(@EXPORT, '&initshellmodule');
string_op('initshellmodule');

sub error {
    my ($optref, @args) = get_options({}, @_);
    Error(@args)
}
push(@EXPORT, '&error');

sub warning {
    my ($optref, @args) = get_options({}, @_);
    Warn(@args)
}
push(@EXPORT, '&warning');

sub inform {
    my ($optref, @args) = get_options({}, @_);
    Info(@args)
}
push(@EXPORT, '&inform');

sub debug {
    my ($optref, @args) = get_options({}, @_);
    Debug(@args)
}
push(@EXPORT, '&debug');

sub markchange {
    my ($optref, @args) = get_options({}, @_);
    MarkChange(@args)
}
push(@EXPORT, '&markchange');

sub gettemp {
    my ($optref, @args) = get_options(\%parse_opt, @_);
    return TempName(@args[0], %{$optref});
}
push(@EXPORT, '&gettemp');
string_op('gettemp');

sub movetemp {
    my ($optref, $tmp) = get_options(\%parse_opt, @_);
    my $target = $tmp;
    $target =~ s/-cfnew//;
    MarkChange("updating $target");
    return unless updating();
    MoveTemp($tmp, $target ,%{$optref});
}
push(@EXPORT, '&movetemp');

sub disable {
    my ($optref, $path) = get_options(\%parse_opt, @_);
    my $rotate = $optref->{ROTATE};

    if (!defined $rotate) {
	# Just remove the path
	Tidy($path, %{$optref}, RECURSE=>1, RMDIR=>1);
	return;
    }

    my $fi = GetFileInfo($path);
    if ($fi->type ne 'NONE') {
	$optref->{OWNER} = $fi->uid unless defined $optref->{OWNER};
	$optref->{GROUP} = $fi->gid unless defined $optref->{GROUP};
	$optref->{MODE} = $fi->perm unless defined $optref->{MODE};
    }

    MarkChange("rotating $path");
    for (my $i = $rotate; $i > 0; $i--) {
	my $backpath = "$path.$i";
	my $prior = ($i == 1) ? $path : ("$path." . ($i-1));
	if (-d $backpath && ! -l $backpath) {
	    die "can't replace directory $backpath with $path\n";
	}
	if (-e $prior && $update) {
	    rename($prior, $backpath)
		    or die "can't move $prior to $backpath: $!\n";
	}
    }
    WriteFile($path, "", %{$optref});
}
push(@EXPORT, '&disable');

sub purge {
    get_options({}, @_);
    PurgeBackupIndex();
    PurgeCksum();
}
push(@EXPORT, '&purge');

#--------
# Initialize environment

# Save copy of flags in environ as it will be reset when we load settings
# from the file
my $envflags = $ENV{CF_FLAGS};

# Determine base of configuration script/module tree

if (not defined $cfbase) {
    # Locate configuration library.

    # First look for library (modules) parallel to this script
    $cfbase = dirname(AbsolutePath($scriptdir));
    if (! -f "$cfbase/relnum") {
	# No library parallel to script - use the default location
	$cfbase = "/var/lib/cf/inputs";
    }
    $ENV{CF_BASEDIR} = $cfbase ;

    # get mode settings from config-file
    my $flagfile = "$vardir/cf-flags";
    if ( -f $flagfile ) {
	SetFlagsFromHash(LoadVars($flagfile));
    }
}

# Get mode settings from environment.
SetFlags(split(':', $envflags));

sub Usage(;$$) {
    my ($exitcode, $message) = @_;
    $exitcode = 1 unless defined $exitcode;

    print STDERR $message, "\n" if defined $message;
    print STDERR <<EOF;
cf [options] [module:]command [command-options] [arg ..]
  run 'cf helpcommands' for list of available commands
  run 'cf helpmodules' for list of available modules
  run 'cf helpmodcommands MODULE' for list of commands for a module
  run 'cf man' for detailed help
EOF
    exit($exitcode);
}


# Command names that can only be used on the command line (because the name
# is illegal/reserved in perl)
my %cmd_alias = (
    'write' => 'writefile',
    'link' => 'makelink',
    'require' => 'requiremodule',
    'directories' => 'directory',
);

sub Main() {
    Usage(1) if ($ARGV[0] eq '-?' or $ARGV[0] eq '--help');
    my ($cmd, @args) = Cf::parse_args(@ARGV);
    Usage(1) if (!defined $cmd);

    # perform command

    $cmd = $cmd_alias{$cmd} if defined $cmd_alias{$cmd};
    my $rv;
    if ($cmd eq 'man') {
	# Generate manual page/extended help
	# autogenerat this instead of using pod?
	require Pod::Usage;
	Pod::Usage::pod2usage(-exitstatus => 0, -verbose => 2)
    } elsif ($cmd =~ /^[a-z]*$/) {
	# Built-in command
	$rv = eval "Cf::$cmd(\@args)";
	if (my $err = $@) {
	    die "$err\n";
	}
    } elsif ($cmd =~ /^(\w*):(.*)/) {
	# Invoke another configuration module
	my $module = $1;
	my $function = $2;

	$rv = Cf::CallModule($module, $function, @args);
    } else {
	Usage(1, "$0: bad command: $cmd");
    }

    my $result_type = Cf::OpResult($cmd);
    if (defined $result_type) {
	exit ($rv ? 0 : 1) if $result_type eq 'boolean';
	print $rv;
    }
}

# Module Cleanup

END { }

#----------------------------------------------------------------------
package Cf::Lock;
use English;

# Create an lock of specified name. Will be held until object is destroyed,
# the process exits, or time limit runs out.

sub new {
    my $proto = shift;
    my $name = shift;
    my $class = ref($proto) || $proto;
    my $self = { name => $name };
    bless($self, $class);

    my $start = time();
    my $now = $start;
    my $vardir = Cf::GetVarDir();

    Cf::RealMakeDir($vardir);
    my %lockmap;
    Cf::TieFile(%lockmap, "$vardir/locks");
    eval {
	if (defined $lockmap{$name}) {
	    # Prior lock recorded - check if valid.
	    my ($lockpid, $locktime) = split(' ', $lockmap{$name});
	    while ( kill(0, $lockpid) ) {
		# Prior locking process still exists.
		$now = time();
		if ($now - $locktime > $flags{LOCK_EXPIRE}) {
		    # Lock has timed out - break it (killing prior process)
		    Cf::Warn("breaking old lock $name from $lockpid");
		    Cf::VerifiedKill($lockpid)
			or die "can't kill proc $lockpid to break lock $name\n";

		} else {
		    # Lock has not expired
		    if ($now - $start >= $flags{LOCK_WAIT}) {
			# We have waited too long - give up.
			die "lock $name held by process $lockpid\n";
		    } else {
			# Keep waiting for prior process to finish
			sleep(2);
		    }
		}
	    }
	    # We get to replace the lock
	}
	$lockmap{$name} = "$PID $now";
    };
    my $err = $@;
    Cf::UntieFile(%lockmap);

    # Throw error if lock failed
    die $err if $err;

    return $self;
}

sub DESTROY($) {
    my $self = shift;
    my $name = $self->{name};
    my $vardir = Cf::GetVarDir();

    my %lockmap;
    Cf::TieFile(%lockmap, "$vardir/locks");

    # Use local error var - otherwise destructor will wipe out exceptions
    # from block where this object is defined (ug!)
    local $@;
    eval {
	if (defined $lockmap{$name}) {
	    my ($lockpid, $locktime) = split(' ', $lockmap{$name});
	    if ($PID != $lockpid) {
		die "can't unlock $name - held by process $lockpid\n";
	    }
	    delete $lockmap{$name};
	}
    };
    my $err = $@;
    Cf::UntieFile(%lockmap);

    # Throw error if unlock failed
    die $err if $err;
}

#----------------------------------------------------------------------
package Cf::FileInfo;
use Class::Struct;

struct( 'Cf::FileInfo' => [
	dev => '$',		# from stat
	ino => '$',		# from stat
	nlink => '$',		# from stat
	uid => '$',		# from stat
	gid => '$',		# from stat
	size => '$',		# from stat
	atime => '$',		# from stat
	mtime => '$',		# from stat
	ctime => '$',		# from stat
	perm => '$',		# Permission bits from mode
	type => '$',		# FILE, DIR, LINK or SPECIAL

	linkdest => '$',	# destination of synbolic link
	dir => '$',		# contents of directory - array ref
	cksum => '$',		# posix cksum checksum (CRC)
	md5 => '$',		# MD5 checksum
	] );

sub exist($) {
    my $self = shift;
    return ($self->type ne 'NONE');
}

#----------------------------------------------------------------------
package Cf::Module;

sub require() {
    my $self = shift;
    my $flagfile = $self->get_config_flag();
    if (-f $flagfile) {
	my $success = Cf::ReadFile($flagfile);
	return if $success;

	my $name = $self->{name};
	die "can't configure $name - failed earlier in this run\n";
    }
    my $lock = $self->lockop("require");
    $self->configure();
}

sub lockop($$) {
    my $self = shift;
    my ($op) = @_;
    my $name = $self->{name};
    return new Cf::Lock("$name:$op");
} 

sub get_config_flag() {
    my $self = shift;
    my $session = Cf::GetSession();
    my $name = $self->{name};
    return "$session/configured/$name";
}

sub set_configured($$) {
    my $self = shift;
    my ($status) = @_;
    Cf::RealWriteFile($self->get_config_flag(), $status);
}

sub configure() {
    my $self = shift;
    eval { $self->call("configure"); };
    my $err = $@;
    $self->set_configured($err?0:1);
    die $err if ($err);
}

sub write_temp($$$) {
    my $self = shift;
    my ($filename, $content) = @_;
    my $name = $self->{name};
    my $session = Cf::GetSession();
    my $path = "$session/svc-$name/$filename";
    Cf::RealWriteFile($path, $content);
    return $path;
}

# Fall back to invoking call() method.
use vars qw($AUTOLOAD);
sub AUTOLOAD {
    my $self = shift();
    my $method = $AUTOLOAD;
    $method =~ s/.*://;   # strip fully-qualified portion
    my @results = eval { $self->call($method, @_); };
    if (my $err = $@) {
	# Report what we were trying to load since I have been burned
	# placing a typo in this package which causes an inexplicable and
	# infuriating failure which is very hard to debug.
	die "failed to autoload $method: $@";
    }

    # Preserve scalar/list context of result
    return (scalar(@results) == 1) ? $results[0] : @results;
}

#----------------------------------------------------------------------
{
package Cf::ScriptModule;

use vars qw(@ISA);
@ISA = qw(Cf::Module);

# Simple config module that invokes a script for each method.

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = { name => shift, script => shift };
    bless($self, $class);
    return $self;
}

sub DESTROY {}

# Invoke method by name
sub call {
    my $self = shift;
    my $function = shift;
    Cf::PreSpawn();
    system($self->{script}, $function, @_) == 0
	    or die ($self->{name}).":$function failed\n";
}

}

#----------------------------------------------------------------------
{
package Cf::ModuleWrap;

use vars qw(@ISA);
@ISA = qw(Cf::Module);

# Config module that invokes package subroutines for each method.

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = { name => shift, package => shift };
    bless($self, $class);
    return $self;
}

sub DESTROY {}

# Invoke method by name
sub call {
    my $self = shift;
    my $package = $self->{package};
    my $function = shift;
    my @results = eval sprintf('%s::%s(@_);', $package, $function);
    die $@ if $@;

    # Try to preserve scalar/list context of result (yech - i really hate
    # this aspect of perl)
    return (scalar(@results) == 1) ? $results[0] : @results;
}

# Get list of export operations and brief descriptions (hash converted to
# list)
sub GetOps {
    my $self = shift;
    my $package = $self->{package};

    my $module = $package;
    $module =~ s/^Cf::Module:://;

    return Cf::GetModuleOps($module);
}

}

#----------------------------------------------------------------------
package main;

import Cf;
use English (-no_match_vars);

# Precautionary permission mask.
# !!! shouldn't I let user set this?
umask(022);

# Process command line if this is the main program (not used as module)
if ($PROGRAM_NAME eq __FILE__) {
    Cf::Main();
    exit(0);
}

1;

__END__

=head1 NAME

sample - Using cf

=head1 SYNOPSIS

cf [I<options>] I<cf-command> [I<comand-options>] [I<arg> ..]

 Global Options:
    --debug, -d			Display debugging messages
    --inform, -I		Display any changes made
    --dry-run, --test, -n	Just pretend to make changes
    --log 1/0/syslog:facility	Set log mode
    --splay minutes		Random delay at start
    --help			Display this page

 Commands:
   changes [base-count]		get count of config changes performed so far
				(since last count - or since session started if
				no base count is provided)
   copy src dest		Copy src file(s) to dest
   debug message ..		Log debugging message
   deletelines file pattern	
   directory dir ..		Create directory(s)
   disable [-rotate] file ..	Remove or rotate files
   error message ..		Log error message
   file path ..			Create file or fix attributes
   fix path ..			Fix file attributes
   getmount file		Get mount-point for specified path
   getos [part]			Get operating system info
   gettemp dest			Get temporary path name to use when preparing
   				new contents for specified file (see movetemp)
   geturl url [dest]		Get contents of specified URL. If dest is
   				specified then save contents in that file,
				otherwise return contents of URL.
   initshellmodule path		Returns shell commands to initialize current
   				scripts as a cf module - should be executed
				by the script:
				    eval `cf initshellmodule $0`
   
   link src dest		Link dest to src
   loadregistry src		Load (and apply) registry settings from
   				specified file
   man				Display manual page
   markchange message		log that change occured (not using cf
   				primitives - advanced use only)
   movetemp dest		Move temporary file into specified final
				destination. The temp file location should have
				been acquired using gettemp.
   purge			Remove obsolete entries for stated databases
   				(periodic maintenance)
   rcopy src-url dest		Copy files from network volume to dest
   require module ..		Configure modules (if not already configured)
   run cmd arg ..		Execute external command
   setline path pat line	Make sure file contains line
   setregistry keypath val	Set specified to value (windows only)
   showlog			Return contents of current log.
   tidy file ..			Remove specified files
   toc dir			Generate table-of-contents for directory
   touch path ..		Set modification time of files to now.
   updating			Check if really updating (no dry run)
   warning message ..		Log warning message.
   write file content		Write specified data to file

   module:function arg ..	call extension module

 Command Options:
    --changetype
    Allow file types to be changed (for example, replace regular files with
    links).

    --checktype
    Don't allow file types to be changed (opposite of --changetype). Default.

    --dirmode permission
    In recursive operation, use this permissions for directories (override
    any --mode option)

    --group group
    -g group
    Set file group to specified group name or ID.

    --mode permission
    -m permission
    Set file permission bits to speficied value (chmod style relative values
    accepted too - "a+r")

    --purge
    --delete
    -d
    Remove target files with corresponding source files.

    --recurse depth
    -r depth
    Recursively examine files.

    --skipmissing
    Ignore if file to be checked does not exist.

    --user user
    -u user
    --owner user
    Set file owner to specified user name or ID.

    --rmdir

    --follow
    --followlinks

    --rotate count

    --atime days
    --age days

    --mtime days

    --ctime days

    --include regex
    -i regex

    --exclude regex
    -e regex

    --backup all|original|last|none
    --backupdir path

    --copytype mtime|cksum|md5|binary|softlink|hardlink

    --verify none|cksum|md5|binary

    --newtime
    Set modification time of copied files to current time (default is
    to preserve modification time of the source file)

    --field cksum|md5
    Include specified field in table of contents. This option can be repeated.

    --timeout secs

    --chdir path

    --preview

    --tempdir path

    --umount

    --prepend bool

=cut
