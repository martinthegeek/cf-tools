#!/usr/bin/env perl

# $Id$


# TODO !!!
#
# Something to ensure we get the correct perl? PATH reset in call_module()
# could remove the current (preferred) PERL.
#
# Track changes in DRYRUN mode so that later file comparisons are made
# correctly.
#
# Consistent path manipulation
#
# Add timeout option to run - see perlipc and search for alarm - or use code
# from old start script.
#
# Implement undo from log


use strict;

#----------------------------------------------------------------------
package Cf;

my $scriptdir;
BEGIN {
    # Add script's directory to module search path and PATH
    use FindBin;
    $scriptdir = $FindBin::Bin;
    push(@INC, "$scriptdir/lib/perl");
    if ($ENV{PATH} !~ /^$scriptdir:/) {
	# !!! this PATH is not ms-windows portable
	$ENV{PATH} = "$scriptdir:$ENV{PATH}";
    }
}

use AnyDBM_File;
use Class::Struct;
use Cwd;
use English;
use Fcntl qw( :DEFAULT :flock);
use File::Compare;
use File::Copy;
use File::Path;
use File::Basename;
use File::Find;
use IPC::Open3;
use IO::File;

BEGIN {
    use Exporter ();
    use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);

    # set the version for version checking
    $VERSION     = 1.00;

    @ISA         = qw(Exporter);
    @EXPORT      = ( );
    %EXPORT_TAGS = ( );

    # your exported package globals go here,
    # as well as any optionally exported functions
    @EXPORT_OK   = ( );
}

#-----
# Globals

# Boolean: true if microsoft windows platform. Otherwise, a posix system is
# assumed.

my $is_win = ($^O eq 'MSWin32');

# Where to store our state files.

my $vardir = ($UID == 0) ? '/var/lib/cf' : "$ENV{HOME}/.cf";

# base of configuration script/module tree

my $cfbase = $ENV{CF_BASEDIR};

# Modal flags
my %flags = (
    INFORM => 0,	# notify of any changes made?
    DRYRUN => 0,	# don't actually make changes
    DEBUG => 0,		# display debugging output
    LOG => 0,		# log messages to system log
    NEW_TIME => 0,	# update time when copying?
    COPY_TYPE => 'mtime',	# method for comparing files
    VERIFY => 'none',		# method for verifying files
    BACKUP => 'original',	# when to backup
);

# Boolean: actually perform updates (as opposed to going
# through the motions and reporting what would be done.)

my $update;

# Root of UNIX filesystem - under windows, will be replaced with the
# (windows) path to the cygwin root.

my $rootdir = '';

# Maximum series of links to follow to find a real target (to avoid infinite
# link loops).
my $max_links = 10;

#--------
# Parsing of configuration options.

sub parse_string { return $_[0] }
sub parse_int { return int($_[0]) }
sub parse_float { return $_[0]+0.0 }
sub parse_enum {
    my $arg = shift;
    foreach my $val (@_) {
	return $val if $arg eq $val;
    }
    die "bad choice: $arg (should be " . join(', ', @_), ")\n";
}

my %bools = (
    1 => 1, YES => 1, Y => 1, TRUE => 1,
    0 => 0, NO => 0, N => 0, FALSE => 0,
);
sub parse_bool { return $bools{uc($_[0])} }

push(@EXPORT, qw(&parse_string &parse_int &parse_float &parse_enum
	@parse_bool));

# Could break this up by operation... - but that would make it harder to avoid
# conflicts.
my %parse_opt = (
    OWNER => \&parse_string,
    USER => "OWNER",
    U => "OWNER",
    GROUP => \&parse_string,
    G => "GROUP",
    MODE => sub {
	my $mode = $_[0];
	# Make sure file mode numbers are interpreted in octal
	$mode = "0$mode" if ( $mode =~ /^[1-9]/ );
	return $mode;
    },
    M => "MODE",

    CHANGE_TYPES => '',
    CHANGETYPE => 'CHANGE_TYPES',
    CHECKTYPE => '!CHANGE_TYPES',

    SKIP_MISSING => '',
    SKIPMISSING => "SKIP_MISSING",

    PURGE => '',
    DELETE => "PURGE",
    D => "PURGE",
    PURGE_EXCLUDED => "PURGE=EXCLUDED",
    DELETE_EXCLUDED => "PURGE=EXCLUDED",

    RMDIR => '',

    FOLLOW_LINKS => '',
    FOLLOWLINKS => "FOLLOW_LINKS",
    FOLLOW => "FOLLOW_LINKS",

    RECURSE => \&parse_int,
    R => "RECURSE",

    ROTATE => \&parse_int,

    ATIME => \&parse_float,
    AGE => "ATIME",
    MTIME => \&parse_float,
    CTIME => \&parse_float,

    INCLUDE => sub {
	my ($arg, $optref) = @_;
	push ( @{$optref->{EXCLUDE}}, InGlob($arg) );
	return undef;
    },
    I => "INCLUDE",
    EXCLUDE => sub {
	my ($arg, $optref) = @_;
	push ( @{$optref->{EXCLUDE}}, ExGlob($arg) );
	return undef;
    },
    E => "EXCLUDE",

    BACKUP => sub { parse_enum(uc($_[0]), 'ALL', 'ORIGINAL', 'LAST', 'NONE') },
    BACKUPDIR => \&parse_string,

    COPY_TYPE => sub { parse_enum(uc($_[0]),
	'MTIME', 'CKSUM', 'MD5', 'BINARY'
    ) },
    COPYTYPE => 'COPY_TYPE',

    VERIFY => sub { parse_enum(uc($_[0]),
	'NONE', 'CKSUM', 'MD5', 'BINARY'
    ) },

    'TOC_FIELD' => sub {
	my ($arg, $optref) = @_;
	push ( @{$optref->{TOC_FIELDS}},
		parse_enum(uc($arg), 'CKSUM', 'MD5')
		);
	return undef;
    },
    FIELD => 'TOC_FIELD',

);

# Usage: get_options parser-hashref arg ..

sub get_options($@) {
    my $parse_href = shift;
    my %opts = ();
    while (@_[0] =~ /^-/) {
	my ($opt,$arg) = split('=', shift(@_), 2);
	my $opt = uc($opt);
	last if $opt eq '--';

	# Trim all leading dashes
	$opt =~ s/^-*//;
	# Replace remaining dashes with underscore
	$opt =~ s/-/_/g;

	die "bad option: $opt\n" unless defined $parse_href->{$opt};
	my $parser = $parse_href->{$opt};
	if (!ref($parser)) {
	    if ($parser =~ /^!(.*)/) {
		# Inversion of option without argument
		$opts{$1} = 0;
		next;
	    }
	    if ($parser =~ /^(\w*)=(.*)/) {
		# Option alias with implied value
		$opts{$1} = $2;
		next;
	    }

	    if ($parser ne '') {
		# Option is an alias - get parser from real option
		$opt = $parser;
		$parser = $parse_href->{$opt};
	    }

	    if ($parser eq '') {
		# Option does not take an argument
		$opts{$opt} = 1;
		next;
	    }
	}
	$arg = shift(@_) if not defined $arg;
	my $val = &$parser($arg, \%opts);
	$opts{$opt} = $val if defined $val;
    }
    return (\%opts, @_);
}
push(@EXPORT, '&get_options');

# Parse command line options.

my %global_opts = (
    INFORM => '',
    I => 'INFORM',

    DRYRUN => '',
    N => 'DRYRUN',
    DRY_RUN => 'DRYRUN',
    RECON => 'DRYRUN',
    TEST => 'DRYRUN',
    
    DEBUG => '',
    D => 'DEBUG',
    
    SPLAY => \&parse_int,

    LOG => \&parse_string,
);
sub parse_args(@) {
    my ($optref, @args) = get_options(\%global_opts, @ARGV);

    if ($optref->{SPLAY}) {
	# Introduce random delay up to $splay minutes - generally used to keep
	# all machines from hitting the cfmaster at the same time.
	sleep(rand($optref->{SPLAY}*60));
    }
    delete $optref->{SPLAY};

    # Remaining options are modal flags.
    Cf::SetFlagsFromHash(%{$optref});

    return @args;
}
push(@EXPORT, '&parse_args');

# Define result types for exported function - so that we can return results to
# command line scripts.

# !!! should these go into a module variable - that way modules don't need to
# know their own name. Or just define their name ... that may be simpler.

my %op_results = ();
sub OpResult($) {
    my ($opname) = @_;
    return $op_results{$opname};
}
sub string_op($) {
    my ($opname) = @_;
    $op_results{$opname} = 'string';
}
sub boolean_op($) {
    my ($opname) = @_;
    $op_results{$opname} = 'boolean';
}

# Update modal flags - each arguments if a mode flag optionally followed
# with "=" and a value. If no value is provided sets the flag to 1.

sub SetFlags(@) {
    foreach my $setting (@_) {
	next if $setting eq "";

	# get value for key (1 if not specified)
	my ($key, $value) = ($setting, 1);
	if ($setting =~ /(\w*)=(.*)/ ) {
	    # Value specified for key.
	    $key = $1;
	    $value = $2;
	}
	$key = uc($key);

	die "unknown flag: $key\n" unless defined $flags{$key};
	$flags{$key} = $value;
    }
    SetLogging($flags{LOG});
    $update = not $flags{DRYRUN};

    # Export new flags to environment
    my @new_env = ();
    foreach my $key (sort(keys(%flags))) {
	push(@new_env, "$key=$flags{$key}") unless ($flags{$key} eq '0');
    }
    my $flagstr = ":".join(':', @new_env).":";
    $ENV{CF_FLAGS} = $flagstr;
    Debug("flags are: $flagstr");
}

sub SetFlagsFromHash(%) {
    my (%h) = @_;
    my @flaglist = ();

    foreach my $key (keys(%h)) {
	push(@flaglist, "$key=".$h{$key});
    }
    if (@flaglist) {
	SetFlags(@flaglist);
    }
}

# Try to find named progam in listed directory. Return full path of program
# if succesful, otherwise throws an exception.

sub FindProgram($@) {
    my ($progname, @dirs) = @_;
    my @endings = ($is_win) ? ('.exe', '.com', '.bat') : ('');
    foreach my $dir (@dirs) {
	foreach my $suffix (@endings) {
	    my $path = $dir . "/$progname$suffix";
	    Debug('trying (' . $dir . ') ' . $path);
	    return $path if (-x $path && !(-d $path));
	}
    }
    die "could not locate program $progname";
}

#-------
# Path manipulation .. no longer used but should do something instead of the
# current adhoc manipulation.

sub GetPath() {
    my $sep = ($is_win) ? ';' : ':';

    return split($sep, $ENV{PATH});
}

sub PrependPath(@) {
    my $sep = ($is_win) ? ';' : ':';

    $ENV{PATH} = join($sep, @_) . $sep . $ENV{PATH};
}

# Convert native-OS or perl-style file path to cygwin-style path.

sub CygPath($) {
    my ($path) = @_;

    if ($is_win) {
	$path =~ s{\\}{/}g;
	$path =~ s{^([a-zA-Z]):/}{/cygdrive/$1/};
    }
    return $path;
}

# Convert cygwin-style file path to perl-style path.

sub UncygPath($) {
    my ($path) = @_;

    if ($is_win) {
	# Replacing /cygdrive/*/ with *:/

	$path =~ s{^/cygdrive/([a-zA-Z])/}{$1:/};

	if ( $path =~ m{^/[^/]} ) {
	    # Path is relative to UNIX (cygwin) root - prepend the root
	    # directory.
	    $path = $rootdir . $path;
	}
    }
    return $path;
}

# Convert perl-style or cygwin-style file path to native OS file path.

sub SysPath($) {
    my ($path) = @_;

    if ($is_win) {
	$path = UncygPath($path);
	$path =~ s{/}{\\}g;
    }
    return $path;
}

# Convert native OS file path to perl-style path (replace any backslashes
# with forward slashes).

sub UnsysPath($) {
    my ($path) = @_;

    if ($is_win) {
	$path =~ s{\\}{/}g;
    }
    return $path;
}

#-------
# Change tracking

# Return boolean: 1 if in update mode, 0 if in dry-run mode.

sub updating {
    my ($optref) = get_options({max=>0}, @_);
    return $update;
}
push(@EXPORT, '&updating');
boolean_op('updating');

# Get count of changes made so far. Handy to determine if system is actually
# changed during a routine (compare change count from start and end).

my $change_count;
my $change_file;
my $last_read_changes = 0;
sub ChangeCount() {
    if (!defined($change_count)) {
	if (defined $change_file) {
	    # In a multi-process configuration session - get changes from
	    # session state.
	    $last_read_changes = ReadFile($change_file);
	}
	$change_count = $last_read_changes;
    }
    return $change_count;
}

# Record that a configuration change has occured.

sub MarkChange(@) {
    Info(@_);
    ChangeCount();
    $change_count++;
    if (defined($change_file) && $change_count == $last_read_changes + 1) {
	# Always write out the first change after sync with change file - so
	# that if the process exits it will be noted that a change has
	# occured.
	RealWriteFile($change_file, $change_count);
    }
}

# Print count of config changes so far (or since prior invocation)

sub changes {
    my ($o, $initial) = get_options({}, @_);
    $initial = 0 unless defined $initial;
    return ChangeCount()-$initial;
}
push(@EXPORT, '&changes');
string_op('changes');

#-------
# Module management

# Hash of defined modules by name.
my %modules = ();

sub GetModule($) {
    my ($modname) = @_;
    return $modules{$modname} if defined $modules{$modname};

    my $base = GetBase();
    my $module;
    if (-f "$base/$modname/configure.pl") {
	Debug("load (perl) cf module $modname");
	$module = LoadPerlMod("$base/$modname/configure.pl");
    } elsif (-x "$base/$modname/configure") {
	Debug("load (script) cf module $modname");
	$module = new Cf::ScriptModule($modname, "$base/$modname/configure");
    } else {
	die "unknown module: $modname (base=$base)\n";
    }
    $modules{$modname} = $module;
    return $module;
}

sub testmod {
    my ($optref, @modules) = get_options({}, @_);
    my $base = GetBase();
    if (scalar(@modules) == 0) {
	foreach my $script (
		glob("$base/*/configure.pl"),
		glob("$base/*/configure"),
		) {
	    push(@modules, basename(dirname($script)));
	}
    }
    foreach my $mod (@modules) {
	GetModule($mod);
    }
}
push(@EXPORT, '&testmod');

sub CallModule($$@) {
    my ($modname, $function, @args) = @_;

    # Make sure we have a session
    GetSession();

    my $module = GetModule($modname);
    return $module->call($function, @args);
}

# If specified file exists read simple config settings from the file (var=val)
# a return list of alternative setting names and values.

sub LoadVars($) {
    my ($file) = @_;
    return unless -f $file;
    open(FILE, "<$file") or die "can't open $file: $!\n";
    my @vals = ();
    while (my $line = <FILE>) {
	next if $line =~ /^\s*$/;	# Skip empty lines
	next if $line =~ /^\s*#/;	# Skip comments
	$line =~ s/[\cM\cJ]*$//;	# chomp() for any text format
	my ($key, $val) = split('=', $line, 2);
	push(@vals, $key, $val);
    }
    close(FILE) or die $!;
    return @vals;
}

sub LoadPerlMod($) {
    my ($script) = @_;
    my $dir = AbsolutePath(dirname($script));
    my $name = basename($dir);
    my $host = Cf::GetHost();

    my $package = "Cf::Module::$name";
    my $module = new Cf::ModuleWrap($name, $package);

    my $global_defs = "";
    my %vars = (LoadVars("$dir/site.ini"),
	    LoadVars("$dir/PERHOST/$host/host.ini"));
    foreach my $key (keys(%vars)) {
	if ($key =~ /^svc_/) {
	    eval { Cf::GetModule($vars{$key}) };
	    if ($@) {
		# Skip definition if module not found - it might be a
		# compile-only module.
		next if $@ =~ /^unknown module:/;

		die $@;
	    }
	    $global_defs .= sprintf('my $%s = Cf::GetModule(\'%s\');',
		    $key, $vars{$key});
	} else {
	    $global_defs .= sprintf('my $%s = \'%s\';', $key, $vars{$key});
	}
    }
    eval "package $package;"
	. 'BEGIN { import Cf; }'
	. 'my $this_svc = $module;'
	. 'my $this_dir = $dir;'
	. $global_defs
	. Cf::ReadFile($script);
    die "while loading $script: $@" if $@;
    return $module;
}

# Make sure requested modules have been configured (if they haven't configure
# them now)

sub requiremodule {
    my ($optref, @modules) = get_options({}, @_);
    foreach my $module (@modules) {
	GetModule($module)->require();
    }
}
push(@EXPORT, '&requiremodule');

# Configure all (appropriate) services
sub all {
    my ($optref) = get_options({}, @_);

    # Make sure we have a session.
    GetSession();

    my $host = GetHost();
    # !!! don't like this location for all services - invading the otherwise
    # independent cf service
    my $svfile = GetBase() . "/cf/PERHOST/$host/services";
    die "no configuration defined for this host: $host\n" unless (-f $svfile);

    Lock("all");

    open(FILE, "<$svfile") or die $!;
    my @svcs = <FILE>;
    close(FILE) or die $!;
    foreach my $svc (@svcs) {
	$svc =~ s/[\cM\cJ]*$//;		# chomp() for any text format
	GetModule($svc)->require();
    }

    Unlock("all");
}


#-------
# Miscellaneous admin utilities.

# Usage: DisplayMessage($message)
# Display message box in background (spawn a separate process).
# Windows only for now - do I want something similar for UNIX? Send mail to
# logged in users instead (could extend to include people using various
# services like samba ...)?

sub DisplayMessage($) {
    my $message = shift();
    my $pobj;

    Sendmail("cfengine notice", $message, LocalUsers());
}


my @users;
sub LocalUsers() {
    if (!scalar(@users)) {
	if ($is_win) {
	    require Win32::NetAdmin;
	    Win32::NetAdmin::LoggedOnUsers('', \@users);
	} else {
	    my %uflag = ();
	    foreach my $line (split("\n", ReadCommand("who"))) {
		if ($line =~ /^(\w+)/) {
		    $uflag{$1} = 1;
		}
	    }
	    @users = keys(%uflag);
	}
    }
    return @users
}


sub Sendmail($$@) {
    require Mail::Sender;

    my ($subject, $message, @recipients) = @_;
    my $sender = new Mail::Sender( {smtp => 'mailhost'} );
    die "Mail failed: $Mail::Sender::Error" if !ref($sender);

    my $user = 'nobody';
    foreach my $varname ('LOGNAME', 'USERNAME') {
	if ($ENV{$varname}) {
	    $user = $ENV{$varname};
	    last;
	}
    }

    # Send the mail.
    my $result = $sender->MailMsg( {
	    to => join(', ', @recipients),
	    from => $user,
	    subject => $subject,
	    msg => $message,
	    } );
    die "Mail failed: $Mail::Sender::Error" if !ref($result);
}


#----------------------------------------------------------------------
# Registry utility routines.

if ($is_win) {
    # MS-Windows

    # Load registry.

    require Win32;
    require Win32::TieRegistry;
    import Win32::TieRegistry(Delimiter => '/', SplitMultis => 1);
}

# Usage: Registry($keypath)
# Get reference to named (relative to root) key in registry. Returns key
# reference.

sub Registry($) {
    my $path = shift();

    # I have to use the fully qualified name for Registry as it is
    # dynamically imported - is there some way to avoid coding in the
    # package name here?
    my $key = $Cfscript::Registry->{$path} 
	or die "can't open registry key, $path: $^E";

    return $key;
}

# Usage: SetRegistry($key, $name, $value, $type)
# Make sure registry item has specified value/type. Create ancestral subkeys
# as required.
# Returns 1 if registry is modified, 0 otherwise (either the registry
# already contains the correct value or not in update mode).

sub SetRegistry($$$$) {
    my ($key, $name, $value, $type) = @_;
    my $keypath = $key->Path();
    my $message = "setting $keypath$name to ";
    my ($delim) = $key->GetOptions('Delimiter');

    # If registry type is dword, make sure value is hexadecimal formatted.

    if ($type eq 'REG_DWORD' && $value !~ /^0x/) {
	$value = sprintf("0x%4.4x", $value);
    }

    # Check if current value matches desired one - if so return, otherwise
    # append to message saying what the new and old values are.

    if ($type eq 'REG_MULTI_SZ') {
	my $oldref = $key->{$name};
	if (defined($oldref)) {
	    return 0 if (join("\0", @{$value}) eq join("\0", @{$oldref}));
	} else {
	    $oldref = [];
	}
	$message .= "@{$value} ($type) (old was @{$oldref})";
    } else {
	my $old = $key->{$name};
	if (defined($old)) {
	    if ($type eq 'REG_DWORD') {
		return 0 if ( hex($old) == hex($value) );
	    } else {
		return 0 if ( $old eq $value );
	    }
	} else {
	    $old = '';
	}
	$message .= "$value ($type) (old was $old)";
    }

    # Split name into list of subkeys and the item name.

    my @subkeys = split($delim, $name);
    my $item = pop(@subkeys);

    # Inform what keys will be created.

    my $subpath = '';
    foreach my $subkey (@subkeys) {
	$subpath .= $subkey . $delim;
	if ( !defined($key->{$subpath}) ) {
	    MarkChange("creating registry key $keypath$subpath");
	}
    }
    MarkChange($message);

    return 0 unless ( $update );

    foreach my $subkey (@subkeys) {
	my $nextkey = $key->{"$subkey$delim"};
	if (!defined($nextkey)) {
	    $nextkey = $key->CreateKey($subkey)
		    or die "failed to create registry key, $subkey: $^E";
	}
	$key = $nextkey;
    }
    $key->SetValue($item, $value, $type)
	    or die "failed to set registry, $item/$value: $^E";
    return 1;
}

# Usage: DeleteRegistry($key, $name)
# Delete specified item from registry.  Returns 1 if registry is
# modified, 0 otherwise (either the registry value did not exist,
# or not in update mode).

sub DeleteRegistry($$) {
    my ($key, $name) = @_;

    return 0 if !defined($key->{$name});

    MarkChange("deleting ", $key->Path(), $name);

    return 0 unless ( $update );
    delete $key->{$name};
    return 1;
}

# Usage: FlushRegistry($key)
# Flush all registry updates, and perform a 'RegFlushKey' on the specified
# registry key.

sub FlushRegistry($) {
    my ($key) = @_;

    Debug("flushing ", $key->Path());
    if ( $update ) {
	$Cfscript::Registry->Flush();
	$key->RegFlushKey();
    }
}


#----------------------------------------------------------------------
# Logging

# Define whether we are logging to the system log (and how).

my $logging = '0';
my $logtype = 'none';
my $logfh;
sub SetLogging($) {
    my ($newlog) = @_;

    return if ($newlog eq $logging);
    if ($newlog =~ /^syslog(:(.*))?/) {
	my $facility = $2 || 'user';

	require Sys::Syslog;
	import Sys::Syslog;

	# Open connectio to system log - make sure to use unix domain
	# socket as secure configurations (redhat linux) default to
	# rejecting network log messages.

	Sys::Syslog::setlogsock('unix');
	openlog(basename($0), 'pid', $facility);
	$logtype = 'syslog';

	# Close file log.
	if (defined $logfh) {
	    close($logfh);
	    $logfh = undef;
	}
    } else {
	closelog() if $logtype eq 'syslog';

	if ($newlog eq "1") {
	    $logtype = 'file';
	} elsif ($newlog eq "0") {
	    $logtype = 'none';
	} else {
	    die "invalid logging value: $logging\n";
	}
    }
    $logging = $newlog;
    Debug("logging changed to $logging");
}

# Log a message

sub Log ($$$@)
{
    my ($fh, $file_level, $priority, @msgs) = @_;
    my $message = join('', @msgs);

    my $maxlen = 900;
    my @messages = ();

    # Save log message only if this run is for real.
    if ($logtype ne 'none' && $update) {
	if ($logtype eq 'syslog') {
	    # Write message to system log.

	    # Syslog splits messages over UDP packet length - split before
	    # ourselves so there is enough information to join them again

	    my $tail = $message;
	    while (length($tail) > $maxlen) {
		push(@messages, (substr($tail, 0, $maxlen) . "..."));
		$tail = ("..." . substr($tail, $maxlen));
	    }
	    push(@messages, $tail);

	    # I have occasional times when syslog will throw an exception -
	    # if it does fall back to writing to stdout/stderr.

	    eval {
		foreach my $submessage (@messages) {
		    syslog($priority, '%s', $submessage);
		}
	    };
	    return unless $@;
	    print(STDERR ":error:syslog failed:$@\n");
	} else {
	    # Write to our own log.
	    if (!defined $logfh) {
		$logfh = new IO::File;
		RealMakeDir($vardir);
		open($logfh, ">>$vardir/log")
		    or die "can't append to $vardir/log\n";
		$logfh->autoflush(1);
	    }
	    my $tstamp = time();
	    print($logfh "$tstamp $file_level $message\n");
	}
    }

    # Check that display of this type of message is enabled.
    return if ($priority eq 'info' and !$flags{INFORM});
    return unless defined $fh;

    # Display message.
    # !!! Note that the format of this message is (was) designed to work
    # nicely as a cfengine "preview" shellcommand.

    print($fh ":$file_level:$message\n");
}

sub Error {
    Log(*STDERR, 'error', 'err', @_);
}

sub Warn {
    Log(*STDERR, 'warn', 'warning', @_);
}

sub Info {
    Log(*STDERR, 'info', 'info', @_);
}

sub Debug {
    if ($flags{DEBUG}) { Log(*STDERR, 'debug', 'debug', @_); }
}

sub Undo {
    my @args = ();
    foreach my $arg (@_) {
	push(@args, Encode($arg));
    }
    Log(undef, 'undo', 'notice', join(' ', @args));
}

#----------------------------------------------------------------------
# File utilities (internal) - don't obey operational modes, convergence,
# or other nice policies.

# Write content (with trailing newline) to a file.

sub RealWriteFile($$) {
    my ($path, $content) = @_;

    RealMakeDir(dirname($path));
    open(FILE, ">$path") or die "can't write to $path: $!\n";
    print(FILE $content) or die $!;
    if (length($content)) {
	print(FILE "\n") or die $!;
    }
    close(FILE) or die $!;
}

# Recursive delete. Does not follow symlinks.

sub RealRemoveTree($) {
    my ($dir) = @_;

    if ( (! -l $dir) && -d _ ) {
	rmtree($dir, 0, 0);
    } else {
	unlink($dir);
    }
    die "can't remove $dir: $!" if (-l $dir || -e _);
}

sub RealMakeDir(@) {
    foreach my $dir (@_) {
	mkpath($dir);
	die "can't create $dir: $!\n" unless (-d $dir);
    }
}

# Read contents of named file, and return contents with trailing newline
# removed.

sub ReadFile {
    my ($filename) = @_;
    open(FILE, "<$filename") or die "can't open $filename: $!";
    my $contents = join('', <FILE>) ;
    close FILE;
    chomp($contents);

    return $contents;
}
sub read_file {
    my ($optref, $path) = get_options({}, @_);
    ReadFile($path);
}
push(@EXPORT, '&read_file');

sub TempName {
    my ($dest) = @_;

    die "empty destination for TempName()" unless (length($dest));

    # Remove any trailing /s on path (so we can append to the basename)
    $dest =~ s{/+$}{};
    die "can't create temp for root directory\n" if $dest eq "";

    my $path = "$dest-cfnew";

    if ( -e $path ) {
	# Temporary path already exists - remove it (assume it is from a
	# prior aborted run ... is this reasonably safe?).
	RemoveFile($path, 'BACKUP' => 'NONE');
    }
    return $path;
}

##--------
## Database (hash in file) manipulation

# Tie hash to database file - never mind the type. Acquires an exclusive lock
# on the database file too.

my %tieinfo = ();
sub TieFile(\%$) {
    my ($mapref, $path) = @_;

    RealMakeDir(dirname($path));
    my $lock = "$path.lock";
    my $lockfh = new IO::File;
    open ($lockfh, ">>$lock") or die "can't open $lock: $!\n";
    flock($lockfh, LOCK_EX) or die "can't lock $lock $!\n";
    tie(%{$mapref}, 'AnyDBM_File', $path, O_CREAT|O_RDWR, 0644)
	    or die "can't open $path: $!\n";
    $tieinfo{$mapref} = [$path, $lockfh];
}

# Release tie to database file.

sub UntieFile(\%) {
    my ($mapref) = @_;
    my ($path, $lockfh) = @{ $tieinfo{$mapref} };
    my $lock = "$path.lock";

    untie %{$mapref};
    flock($lockfh, LOCK_UN) or die "can't unlock $lock $!\n";
    close($lockfh) or die $!;
    delete $tieinfo{$mapref};
}


# Create an lock of specified name. Will be held until unlock,
# the process exits, or time limit runs out.

sub Lock($) {
    my ($name) = @_;
    my $now = time();
    my $duration = 60*60;	# default to holding locks for an hour.

    RealMakeDir($vardir);
    my %lockmap;
    TieFile(%lockmap, "$vardir/locks");
    eval {
	if (defined $lockmap{$name}) {
	    my ($lockpid, $locktime) = split(' ', $lockmap{$name});
	    if ( kill(0, $lockpid) ) {
		if ($locktime - $now > $duration) {
		    Warn("breaking old lock $name from $lockpid");
		} else {
		    die "lock $name held by process $lockpid\n";
		}
	    }
	}
	$lockmap{$name} = "$PID $now";
    };
    UntieFile(%lockmap);

    # Throw error if lock failed
    die $@ if $@;
}

sub Unlock($) {
    my ($name) = @_;

    my %lockmap;
    TieFile(%lockmap, "$vardir/locks");
    eval {
	if (defined $lockmap{$name}) {
	    my ($lockpid, $locktime) = split(' ', $lockmap{$name});
	    if ($PID != $lockpid) {
		die "can't unlock $name - held by process $lockpid\n";
	    }
	    delete $lockmap{$name};
	}
    };
    UntieFile(%lockmap);

    # Throw error if unlock failed
    die $@ if $@;
}

# Backup specified file according provided options. Will use a hard link for
# the backup if possible so link needs to be broken before updating path.
#
# WARNING! May actually remove the location (if the target is a directory
# and the backup area is in the same filesystem)
#
# Supported options:
#
#	BACKUPDIR	Where to store backups
#
#	BACKUP		Mode of backups:
#
#		ALL - keep backup of all versions of a path
#		ORIGINAL - keep just the first version of a path
#		LAST - keep just the most recent version
#		NONE - don't keep any backups (BEWARE!)

sub Backup($%) {
    my ($path, %opts) = @_;
    $path = AbsolutePath($path);
    my $bdir = $opts{BACKUPDIR} || "$vardir/backup";
    my $mode = $opts{BACKUP} || uc($flags{BACKUP});


    my $finfo = GetFileInfo($path);
    my $type = $finfo->type;
    if ($type eq 'NONE') {
	Undo('tidy', $path);
	return;
    }
    if ($mode eq 'NONE') {
	Undo('warn', "$path can't be restored (no back up)");
	return;
    }
    die "can't backup $type file: $path"
	   if ($type ne 'FILE' && $type ne 'DIR' && $type ne 'LINK');

    my $dirname = dirname($path);
    my $basename = basename($path);

    # Determine full path to backup directory
    if (IsAbsolute($bdir)) {
	# Nothing to do
    } elsif ($bdir =~ m{\./(.*)}) {
	# Relative path
	$bdir = "$dirname/$1";
    } else {
	die "unrecognized format for BACKUPDIR: $bdir\n";
	# !!! would be nice to have an option to save at base of filesystem
    }

    # Open and lock backup directory. Create directory if it doesn't exist.

    RealMakeDir($vardir);
    RealMakeDir($bdir);
    my %pathmap;
    TieFile(%pathmap, "$vardir/backup.map");

    eval { BACKUP: {
	# Determine backup path

	my $bpath;
	if ($mode eq 'LAST' ) {
	    if (defined $pathmap{$path}) {
		# Backup already exists for this path - reuse that backup
		# location.
		$bpath = $pathmap{$path};
	    }
	} elsif ($mode eq 'ORIGINAL' ) {
	    # Skip if path has already been backed up.
	    if (defined $pathmap{$path}) {
		Undo('warn', "$path can't be restored (no back up)");
		last BACKUP;
	    }
	} elsif ($mode ne 'ALL') {
	    die "unknown backup mode: $mode\n";
	}

	if (!defined $bpath) {
	    # No backup path yet - get one that does not exist yet.

	    my $base = "$bdir/$basename";
	    $bpath = $base;
	    my $count = 1;
	    while (-e $bpath) {
		# keep counting
		$count += 1;
		$bpath = "$base-$count"
	    }
	}

	# Do the backup

	Debug("backing up $path to $bpath");

	# Make sure nothing in the backup location
	RealRemoveTree($bpath);

	my @undo_opts = (
	    -user => $finfo->uid,
	    -group => $finfo->gid,
	    -mode => sprintf("0%03o", $finfo->perm),
	    -mtime => $finfo->mtime,
	);

	if ($type eq 'LINK') {
	    # Really a link - nothing to backup.
	    Undo('link', @undo_opts, ReadLink($path), $path);
	} elsif ($type eq 'DIR') {
	    # path is a directory

	    if (rmdir($path) ) {
		Undo('mkdir', @undo_opts, $path);
	    } else {
		# simple delete failed - directory probably not empty
		# try moving it.

		if (rename($path, $bpath)) {
		    Undo('move', @undo_opts, $bpath, $path);
		} else {
		    # Can't move the directory - try archiving it.

		    Undo('untar', $bpath, $path);
		    my $wd = cwd();
		    chdir($dirname) or die "can't chdir to $dirname: $!";
		    my $rc = system('tar', '-cf', $bpath, $basename);
		    chdir($wd) or die "can't chdir to $wd: $!";

		    die "backup tar failed: $?" unless $rc == 0;
		}
	    }
	} else {
	    # Normal file
	    # Try doing the backup with a hard link unless the file already has
	    # a hard link. If linking does not work just do a copy.

	    # Does not restore hard links :-(
	    Undo('copy', @undo_opts, $bpath, $path);

	    if ($finfo->nlink != 1 || !link($path, $bpath)) {
		File::Copy::copy($path, $bpath)
		    or "failed to backup $path to $bpath: $!\n";
	    }
	}

	$pathmap{$path} = $bpath;
    } };
    UntieFile(%pathmap);

    # Throw error if backup failed
    die $@ if $@;
}

# Remove obsolete entries from the backup index (files purged from the backup
# directory(s)).

sub PurgeBackupIndex() {
    my %pathmap;
    TieFile(%pathmap, "$vardir/backup.map");
    while (my ($path, $bpath) = each(%pathmap)) {
	unless (-e $bpath) {
	    Debug("purging backup entry for $bpath");
	    delete $pathmap{$path} unless (-e $bpath);
	}
    }
    UntieFile(%pathmap);
}

# Move temp file into its permanent location. First check that the file has
# the appropriate attributes (matching passed options).

sub MoveTemp($$%) {
    my ($tmp, $target, %opts) = @_;

    # (Silently) set attributes of temp file.
    my $inform = $flags{INFORM};
    $flags{INFORM} = 0;
    CheckFile($tmp, %opts, RECURSE=>0);
    $flags{INFORM} = $inform;

    Backup($target, %opts);
    my $old;
    if (-d $target && ! -l $target) {
	# Target is a real directory - can't replace with rename. Move
	# target out of the way and we will remove the tree after temp is in
	# place.
	$old = "$target-cfold";
	RealRemoveTree($old) if (stat($old));
	rename($target, $old) or die "can't move $target to $old: $!\n";
    }
    rename($tmp, $target) or die "can't move $tmp to $target: $!\n";
    if ($old) {
	RealRemoveTree($old);
    }
}

sub CheckType($$%) {
    my ($path, $desired_type, %opts) = @_;

    my $type = GetFileInfo($path)->type;
    if ( !$opts{CHANGE_TYPES} and ($type ne 'NONE')
	    and ($type ne $desired_type) ) {
	die "type mismatch, $path is $type (not $desired_type)\n";
    }
    return $type;
}

sub IsAbsolute($) {
    my ($path) = @_;
    if ($is_win) {
	$path = UnsysPath($path);
	return ( $path =~ m{^[A-Za-z]:/} || $path =~ m{^//} );
    } else {
	return ( $path =~ m{^/} );
    }
}
# ???
#sub is_absolute($) {
#    return File::Spec->file_name_is_absolute(@_);
#}

sub AbsolutePath($;$) {
    my ($path, $base) = @_;

    return $path if (IsAbsolute($path));
    $base = cwd() if not defined $base;
    $path = $base . '/' . $path;
    return $path;
}



# File Querying
#
# Want to cache file attributes - mostly for query network repositories and
# for faking updates in dry run mode. Problem is ... don't want to
# over-cache and get stale data.
#
# Also - don't want to load all cache attributes at the same time - 
# checksum in particular


struct( FileInfo => [
	dev => '$',		# from stat
	ino => '$',		# from stat
	nlink => '$',		# from stat
	uid => '$',		# from stat
	gid => '$',		# from stat
	size => '$',		# from stat
	atime => '$',		# from stat
	mtime => '$',		# from stat
	ctime => '$',		# from stat
	perm => '$',		# Permission bits from mode
	type => '$',		# FILE, DIR, LINK or SPECIAL

	linkdest => '$',	# destination of synbolic link
	dir => '$',		# contents of directory - array ref
	cksum => '$',		# posix cksum checksum (CRC)
	md5 => '$',		# MD5 checksum
	] );

# Stored file information, indexed by absolute (canonical) path
my %file_info = ();

sub ReadDir {
    my ($path) = @_;
    if (defined $file_info{$path}) {
	my $childref = $file_info{$path}->dir;
	if ($file_info{$path}->type eq 'DIR' && !defined $childref) {
	    LoadDirTOC($path);
	    $childref = $file_info{$path}->dir;
	}
	return @{$childref};
    }

    my @children = ();

    # Get all children of directory, except "." and ".."
    my %skip = ( "." => 1, ".." => 1,);
    opendir(DIR, $path) or die "$!: $path\n";
    while ( defined(my $child = readdir(DIR)) ) {
	push(@children, $child) unless $skip{$child};
    }
    closedir(DIR);

    return @children;
}

sub ReadLink ($) {
    my ($path) = @_;

    return $file_info{$path}->linkdest if (defined $file_info{$path});
    return readlink($path);
}

sub MD5 ($) {
    my ($path) = @_;
    return $file_info{$path}->md5 if (defined $file_info{$path});

    require Digest::MD5;

    open(FILE, $path) or die $!;
    binmode(FILE);
    my $sum = Digest::MD5->new->addfile(*FILE)->digest;
    close(FILE) or die $!;
    return $sum;
}

##--------
## Checksum cache
## track file checksums and avoid recomputing if the file modtime is unchanged.

# Lookup checksum (and modtime) from checksum cache

my %cksums = ();
sub GetCksum($) {
    my ($path) = @_;
    TieFile(%cksums, "$vardir/cksum") unless tied %cksums;
    return split(' ', $cksums{$path}, 2);
    # or use unpack() / pack ?
}

# Add entry to checksum cache.

sub SetCksum($$$) {
    my ($path, $sum, $mtime) = @_;
    TieFile(%cksums, "$vardir/cksum") unless tied %cksums;
    $cksums{$path} = "$sum $mtime";
    # or use unpack() / pack ?
}

# Remove obsolete entries from the checksum cache.
sub PurgeCksum() {
    TieFile(%cksums, "$vardir/cksum") unless tied %cksums;
    while (my ($path, $info) = each(%cksums)) {
	my ($sum, $mtime) = split(' ', $cksums{$path}, 2);
	my $fi = GetFileInfo($path);
	unless ($fi->mtime == $mtime) {
	    Debug("purging cksum for $path");
	    delete $cksums{$path};
	}
    }
}

my $cksum_ref;
sub Cksum ($) {
    my ($path) = @_;

    # If file info is cached use that cksum (even if none there).
    return $file_info{$path}->cksum if (defined $file_info{$path});

    my $fi = GetFileInfo($path);

    # checksums only make sense for true files - return undef for others.
    return undef unless $fi->type eq 'FILE';

    # Look for checksum in file cache - use cached value if file modtime has
    # not changed since the cached was computed.
    my ($sum, $mtime) = GetCksum($path);
    return $sum if $mtime == $fi->mtime;

    if (not defined $cksum_ref) {
	# figure out how to compute checksum
	eval {
	    require String::CRC::Cksum;
	};
	if ($@) {
	    # Can't load perl module - use external command instead.
	    $cksum_ref = \&CksumExt;
	} else {
	    $cksum_ref = \&CksumInt;
	}
    }

    # compute checksum
    $sum = $cksum_ref->($path);

    SetCksum($path, $sum, $fi->mtime);
    return $sum;
}

sub CksumInt($) {
    my ($path) = @_;
    my $fh = new IO::File;
    open($fh, $path) or die $!;
    binmode($fh);
    my $sum = String::CRC::Cksum::cksum($fh);
    close($fh) or die $!;
    return $sum;
}

sub CksumExt($) {
    my ($path) = @_;
    my $fh = new IO::File;
    open($fh, "cksum $path|") or die $!;
    my $line = <$fh>;
    my ($sum) = split(' ', $line);
    close($fh) or die $!;
    return $sum;
}

sub GetFileInfo($) {
    my ($path) = @_;

    return $file_info{$path} if (defined $file_info{$path});
    my $info = new FileInfo;
    my @st = lstat($path);
    if (!@st) {
	$info->type('NONE');
	return $info
    }

    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	  $atime,$mtime,$ctime,$blksize,$blocks) = @st;

    $info->dev($dev);
    $info->ino($ino);
    $info->nlink($nlink);
    $info->uid($uid);
    $info->gid($gid);
    $info->size($size);
    $info->atime($atime);
    $info->mtime($mtime);
    $info->ctime($ctime);

    $info->perm($mode & 07777);
    if (-l _) {
	$info->type('LINK');
    } elsif ( -f _ ) {
	$info->type('FILE');
    } elsif ( -d _ ) {
	$info->type('DIR');
    } else {
	$info->type('SPECIAL');
    }

    return $info
}

sub fileinfo {
    my ($o, $path) = get_options({'FOLLOW'=>''}, @_);
    $path = FollowLinks($path) if $o->{FOLLOW};
    return GetFileInfo($path);
}
push(@EXPORT, '&fileinfo');
# string_op('fileinfo'); ?? if i add attr query arg?

# Convert glob pattern to corresponding regular expression.
sub glob2pat {
    my $globstr = shift;
    my %patmap = (
	'%' => '.*',
	'*' => '[^/]*',
	'?' => '[^/]',
	'[' => '[',
	']' => ']',
	'-' => '-',
    );
    $globstr =~ s{(.)} { $patmap{$1} || "\Q$1" }ge;
    return '^' . $globstr . '$';
}

# Pattern matching flags for file include/exclude lists
my $EX_FULLPATH = 1;	# Match against full path (default is to just match
			# against the base file name)?
my $EX_INCLUDE = 2;	# Include matching paths (default is to exclude)?

# Generate match item for glob pattern - if the pattern contains a / then
# adds the fullpath matching flag automatically.
sub GlobMatch($$) {
    my ($glob,$flags) = @_;
    $flags |= $EX_FULLPATH if ($glob =~ m{/});
    return ($flags, glob2pat($glob));
}

# Generate a match item that excludes files matching a glob pattern.
sub ExGlob($) { return GlobMatch($_[0], 0) }

# Generate a match item that includes files matching a glob pattern.
sub InGlob($) { return GlobMatch($_[0], $EX_INCLUDE) }

# Check if file path is excluded my a match list. The match list is a
# (reference to) a list of alternating match flags (see $EX_* values defined
# above) and regular expression patterns.

sub IsExcluded($$;$) {
    my ($matches_ref, $path, $default)  = @_;
    $default = 0 if !defined $default;
    my $base = basename($path);

    my $len = @{$matches_ref};
    for (my $i=0; $i < $len; $i += 2) {
	my $flags = @{$matches_ref}[$i];
	my $re = @{$matches_ref}[$i+1];

	my $match;
	if ($flags & $EX_FULLPATH) {
	    $match = $path =~ /$re/;
	} else {
	    $match = $base =~ /$re/;
	}
	if ($match) {
	    my $result = ($flags & $EX_INCLUDE) ? 0 : 1;
	    Debug($result ? "excluding $path" : "including $path");
	    return $result;
	}
    }
    # No match - return default.
    return $default;
}

# Given system ticks of an event return how many days ago it happened.

my $secs_per_day = 60*60*24;
sub Age($) {
    my ($when) = @_;
    return ((time() - $when)/$secs_per_day);
}

#----------------------------------------------------------------------
# (safe) System modifying routines.

=pod

=item CheckFile(path [, option => value ..])

Verify that specified file matches criteria in options.

    OWNER
    GROUP
    MODE

Also obeys the following options when checking

    SKIP_MISSING
    FOLLOW_LINKS
    RECURSE

=cut

sub CheckFile($%) {
    my ($path, %opts) = @_;
    my $fi = GetFileInfo($path);

    if ($fi->type eq 'LINK') {
	# Nothing to do if not traversing links (we don't check perms on
	# (soft) links as they don't matter)
	return if !$opts{FOLLOW_LINKS};

	$path = FollowLinks($path);
	$fi = GetFileInfo($path);
    }

    if ($fi->type eq 'NONE') {
	# File does not exist
	# !!! ignoring in dryrun mode ... ideally should keep track of
	# created files and would verify that prior step would have created
	# the file.
	return if $opts{SKIP_MISSING} or !$update;
	die "file does not exist: $path";
    }

    Debug("checking $path");

    if (defined $opts{'OWNER'}) {
	# check owner of file

	my $user = $opts{'OWNER'};
	my $uid;

	if ( $user =~ /^[0-9]+$/ ) {
	    # User specified as uid.

	    $uid = $user;
	} else {
	    # Assume user specified by name - look up id.
	    # Lookup allowed to fail in nonupdate mode - assume that user
	    # would have been created in an earlier step.

	    my @fields = getpwnam($user);
	    die "user $user unknown" unless (@fields || (!$update));
	    $uid = $fields[2];
	}
	Debug("checking $path owner is $user ($uid), old is " . $fi->uid);
	if ($uid != $fi->uid) {
	    MarkChange("setting owner of $path to $user");
	    if ($update) {
		chown($uid, -1, $path) or die $!;
		$fi = GetFileInfo($path);
	    }
	}
    }
    if (defined $opts{'GROUP'}) {
	# check group of file

	my $group = $opts{'GROUP'};
	my $gid;

	if ( $group =~ /^[0-9]+$/ ) {
	    # User specified as gid.

	    $gid = $group;
	} else {
	    # Assume group specified by name - look up id.
	    # Lookup allowed to fail in nonupdate mode - assume group
	    # would have been created in an earlier step.

	    my @fields = getgrnam($group);
	    die "group $group unknown" unless (@fields or (!$update));
	    $gid = $fields[2];
	}
	Debug("checking $path group is $group ($gid), old is " . $fi->gid);
	if ($gid != $fi->gid) {
	    MarkChange("setting group of $path to $group");
	    if ($update) {
		chown(-1, $gid, $path) or die $!;
		$fi = GetFileInfo($path);
	    }
	}
    }
    #!!! collapse the two chown() calls into one if possible?

    if (defined $opts{'MODE'}) {
	# check mode (permissions) of file

	my $mode = $opts{'MODE'};
	if ($mode =~ /^\d/) {
	    # Numeric mode. Convert from octal if it has a leading 0.
	    $mode = oct($mode) if $mode =~ /^0/;
	} else {
	    # Symbolic mode.
	    require File::chmod;

	    # If DEBUG is on then includes bogus permission validation - so
	    # disable (on by default)
	    $File::chmod::DEBUG = 0;
	    $File::chmod::UMASK = 0;

	    ($mode) = File::chmod::getchmod($mode, $path);
	}
	my $mode_str = sprintf("%04o", $mode);
	Debug("checking $path mode is $mode_str");
	if ($mode != ($fi->perm) ) {
	    MarkChange("setting mode of $path to $mode_str");
	    if ($update) {
		chmod($mode, $path) or die $!;
	    }
	}
    }

    # Check children if this is a directory and recursion was requested.

    if ($fi->type eq 'DIR' && $opts{'RECURSE'} ) {
	$opts{'RECURSE'}--;
	my @args = %opts;
	foreach my $file ( ReadDir($path) ) {
	    CheckFile("$path/$file", @args);
	}
    }
}

sub RemoveFile {
    my ($path, %opts) = @_;

    my $fi = GetFileInfo($path);
    return if ($fi->type eq 'NONE');

    MarkChange("removing $path");

    return unless ($update);

    Backup($path, %opts);
    RealRemoveTree($path);
}

sub CopyFile {
    my ($srcpath, $destpath, %opts) = @_;
    my $compare = $opts{COPY_TYPE} || uc($flags{COPY_TYPE});
    my $verify = $opts{VERIFY} || uc($flags{VERIFY});
    my $newtime = $opts{NEW_TIME};
    $newtime = $flags{NEW_TIME} unless defined $newtime;

    die "can't use binary comparison for remote copy\n"
	    if ($opts{REMOTE_SRC})
		&& ($compare eq 'BINARY' || $verify eq 'BINARY');

    my $si = GetFileInfo($srcpath);
    my $di = GetFileInfo($destpath);

    if (!defined $opts{MODE}) {
	# Mode not explicity set for copy - use source permissions but apply
	# umask.
	$opts{MODE} = ($si->perm & ~umask());
    }

    # Check if source and destination differ - first compare file sizes for
    # a real quick check.

    my $same = ( $di && $si->size == $di->size );
    if ($same) {
	if ( $compare eq 'MD5' ) {
	    $same = (MD5($srcpath) eq MD5($destpath));
	} elsif ( $compare eq 'CKSUM' ) {
	    $same = (Cksum($srcpath) eq Cksum($destpath));
	} elsif ( $compare eq 'MTIME' ) {
	    if ($newtime) {
		$same = ($si->mtime < $di->mtime);
	    } else {
		$same = ($si->mtime == $di->mtime);
	    }
	} elsif ( $compare eq 'BINARY' ) {
	    $same = (compare($srcpath, $destpath) == 0);
	} else {
	    die "unknown comparison method: $compare";
	}
    }

    if ($same) {
	# File content matches, make sure options match then return.
	CheckFile($destpath, %opts, RECURSE => 0) if (scalar(%opts));
	return;
    }

    MarkChange("copying $srcpath to $destpath");
    return unless ($update);

    # Make sure parent directories of $destpath exist
    my $parent = dirname($destpath);
    MakeDir($parent);

    # Safe copy (copy to temp and then move into place)

    my $temp = TempName($destpath);

    eval {
	if ($opts{REMOTE_SRC}) {
	    geturl($srcpath, $temp);
	} else {
	    File::Copy::copy($srcpath, $temp)
		or die "can't copy from $srcpath: $!\n";
	}
    };
    if ($@) {
	unlink($temp);
	die $@;
    }

    unless ($newtime) {
	my $mtime = $si->mtime;
	utime(time(), $mtime, $temp) or die "can't set time on $temp";
    }

    # verify copy - always verify size, optionally validate content.
    my $ti = GetFileInfo($temp);
    die "size changed during copy of $srcpath" unless $ti->size == $si->size;
    if ($verify ne 'NONE') {
	# verify content
	my $same;
	if ( $verify eq 'MD5' ) {
	    $same = (MD5($srcpath) eq MD5($temp));
	} elsif ( $verify eq 'CKSUM' ) {
	    $same = (Cksum($srcpath) eq Cksum($temp));
	} elsif ( $verify eq 'BINARY' ) {
	    $same = (compare($srcpath, $temp) == 0);
	} else {
	    die "unknown verification method: $verify";
	}
	die "$srcpath changed during copy" unless $same;
    }

    MoveTemp($temp, $destpath, %opts);

    # Update checksum database
    SetCksum($destpath, $si->cksum, $ti->mtime) if defined $si->cksum;
}

# Set modification time of file to now (create file if necessary).

sub TouchFile($%) {
    my ($file, %opts) = @_;
    if (-e $file) {
	# File exists, update mtime.
	MarkChange("touching $file");
	return if (!$update);

	my $now = time;
	utime($now, $now, $file) or die $!;
	CheckFile($file, %opts) if (scalar(%opts));
    } else {
	# No file, create empty one.
	WriteFile($file, "", %opts);
    }
}

# Create/replace $filename with data in $content - appends a newline.

sub WriteFile {
    my ($destpath, $content, %opts) = @_;

    if ( -f $destpath ) {
	my $oldcontent = ReadFile($destpath);
	if ($content eq $oldcontent) {
	    CheckFile($destpath, %opts) if (scalar(%opts));
	    return;
	}
    }

    MarkChange("writing $destpath");
    return unless ($update);

    # Make sure parent directories of $destpath exist
    my $parent = dirname($destpath);
    MakeDir($parent);

    my $temp = TempName($destpath);
    RealWriteFile($temp,$content);
    MoveTemp($temp, $destpath, %opts);
}

sub MakeLink {
    my ($src, $dest, %opts) = @_;

    my $desttype = CheckType($dest, 'LINK', %opts);
    Debug("$dest is $desttype");
    if ($desttype eq 'LINK') {
	return if (ReadLink($dest) eq $src);
    }

    MarkChange("linking $dest -> $src");

    # Just print?
    return unless ($update);

    my $temp = TempName($dest);
    symlink($src, $temp) or die $!;
    MoveTemp($temp, $dest);
}

# Synchronize contents of two directories.

sub DirSync {
    my ($srcdir, $destdir, @args) = @_;
    my %opts = @args;
    my %src_exists = ();

    foreach my $file ( ReadDir($srcdir) ) {
	FileSync("$srcdir/$file", "$destdir/$file", @args);
	$src_exists{$file} = 1;
    }

    if ($opts{'PURGE'}) {
	# Remove extraneous files from destination.

	# Not updating so target may not exist
	# !!! this guard is unnecessary if we start faking file info in dry
	# run more.
	if (!$update && GetFileInfo($destdir)->type eq 'NONE') {
	    return;
	}

	# Exluding patterns from purge?
	my $excluding = $opts{EXCLUDE} && ($opts{PURGE} ne 'EXCLUDED');

	foreach my $file ( ReadDir($destdir) ) {
	    if ( !$src_exists{$file} ) {
		my $path = "$destdir/$file";
		unless ($excluding && IsExcluded($opts{EXCLUDE}, $path)) {
		    RemoveFile($path, @args);
		}
	    }
	}
    }
}

# Dereference link (recursively) to get to the real target.

sub FollowLinks($) {
    my ($target) = @_;
    
    my $count = 0;
    my $path = $target;
    while (GetFileInfo($path)->type eq 'LINK') {
	die "too many links (loop?): $target\n" if ($count++ == $max_links);
	my $newpath = ReadLink($path) or die $!;
	$path = AbsolutePath($newpath, dirname($path))
    }
    return $path;
}

#----------------------------------------------------------------------
# Simple network encoding
# Basically URL encoding? (but don't want dependency on full URL module).

my %char2hex = ();
my %hex2char = ();
foreach my $byte (0 .. 255) {
    my $char = sprintf("%c", $byte);
    my $hex = sprintf("%02x", $byte);
    $char2hex{$char} = $hex;
    $hex2char{$hex} = $char;
}
sub Encode($) {
    my ($str) = @_;
    $str =~ s/[^[:alnum:]-_\/\.]/%$char2hex{$&}/g;
    return $str;
}
sub Decode($) {
    my ($str) = @_;
    $str =~ s/%(..)/$hex2char{$1}/g;
    return $str;
}

#----------------------------------------------------------------------
# External routines (exported to scripts)

sub MakeDir {
    my ($path, %opts) = @_;

    my $path = FollowLinks($path);
    my $oldtype = CheckType($path, 'DIR', %opts);
    if ($oldtype eq 'DIR') {
	# Directory already exists, make sure options match then return.
	CheckFile($path, %opts, RECURSE => 0) if (scalar(%opts));
	return;
    }
    MarkChange("creating directory $path");

    # Just print?
    return unless ($update);

    my $temp = TempName($path);
    RealMakeDir($temp);
    MoveTemp($temp, $path, %opts);
}

# Retrieve document from URL - if destination specified then write to that
# file (always - does not follow safe rules). Otherwise return document to
# caller. Throws an exception if the document cannot be retrieved.

my $geturl_ref;
my $gethttp_ref;
my $lwp_ua;
sub geturl {
    my ($optref, $url, $dest) = get_options({}, @_);

    if (not defined $geturl_ref) {
	eval { require HTTP::Lite; };
	$gethttp_ref = \&GeturlLite unless ($@);

	eval {
	    require LWP::UserAgent;
	    require HTML::HeadParser;	# Some boxes are missing this module
	    				# which causes LWP to fail later.
	};
	if ($@) {
	    # No LWP - fall back to curl
	    $geturl_ref = \&GeturlCurl;
	} else {
	    $geturl_ref = \&GeturlLwp;
	    $lwp_ua = LWP::UserAgent->new;
	}
    }
    if ($gethttp_ref && $url =~ /^http:/) {
	return $gethttp_ref->($url, $dest);
    } else {
	return $geturl_ref->($url, $dest);
    }
}
string_op("geturl");

sub GeturlLite($;$) {
    my ($url, $dest) = @_;
    Debug("downloading $url (lite)");

    my $http = new HTTP::Lite;
    my @args = ();
    my $fh;
    if (defined $dest) {
	$fh = new IO::File;
	open($fh, ">$dest") or die "can't write to $dest: $!\n";
	push(@args, \&GeturlLiteCallback, $fh);
    }
    my $req = $http->request($url, @args)
	    or die "failed to get $url: $!\n";
    die "failed to get $url ($req): ".$http->status_message()
	    if $req ne "200";

    if (defined $dest) {
	close($fh) or die $!;
    } else {
	return $http->body();
    }
}

sub GeturlLiteCallback {
    my ($self,$dataref,$cbargs) = @_;
    print $cbargs $$dataref;
    return undef;
}

sub GeturlLwp($;$) {
    my ($url, $dest) = @_;
    Debug("downloading $url (lwp)");
    my $req = HTTP::Request->new(GET => $url);
    my $res;
    if (defined $dest) {
	$res = $lwp_ua->request($req, $dest);
    } else {
	$res = $lwp_ua->request($req);
    }
    die "failed to get $url: ".$res->code if $res->is_error();
    return $res->content unless defined $dest;
}


sub GeturlCurl($;$) {
    my ($url, $dest) = @_;
    my $command = "curl -fsS $url";

    Debug("curling $url");

    # Could do just - but that allows the shell to invade:
    #my $pid = open(PIPE, "$command|");

    my $pid = open(PIPE, "-|");
    if ($pid == 0) {
	# child
	exec('curl', '-fsS', $url) or die "can't exec curl: $!";
	# NOTREACHED
    }
    # Parent

    die "command ($command) failed: $!" unless $pid;

    my $buffer = '';
    my $bufsize = 8*1024;
    my $content = '';
    if (defined $dest) {
	# Direct content to file.
	open(OUT, ">$dest") or die "can't write to $dest: $!";
	while (sysread(PIPE, $buffer, $bufsize)) {
	    print OUT $buffer or die $!;
	}
	close(OUT) or die $!;
    } else {
	# Capture content to return to caller.
	while (sysread(PIPE, $buffer, $bufsize)) {
	    $content .= $buffer;
	}
    }

    close(PIPE) or die "command ($command) failed: $!";
    return $content unless defined $dest;
}

# Generated table of contents for specified directory tree so that it can be
# used as the source for rcopy.

sub MakeTOC($$) {
    my ($dir, $fieldsref) = @_;
    my $header = "# cftoc 1.0";
    $dir = AbsolutePath($dir);
    my @lines = ();
    my %dirlines = ();

    sub TocEntry {
	my $basename = $_;
	return if $basename eq '.cftoc';

	my $relpath = $File::Find::name;
	my $dirpath = $File::Find::dir;
	# Trim off leading "." when joining with relative path
	my $path = $dir . substr($relpath, 1);
	my $fi = GetFileInfo($basename);
	my @opts = ();

	if ($fi->type eq 'DIR') {
	    my $toc = "$header\n";;
	    if (defined $dirlines{$relpath}) {
		$toc .= join("\n", @{$dirlines{$relpath}});
		delete $dirlines{$relpath};
	    }
	    WriteFile("$path/.cftoc", $toc);
	}

	# Try to convert user and group ids to names.
	my $user = $fi->uid;
	if (my @ufields = getpwuid($user)) {
	    $user = $ufields[0];
	}
	my $group = $fi->gid;
	if (my @gfields = getgrgid($group)) {
	    $group = $gfields[0];
	}

	if ($fi->type eq 'LINK') {
	    push(@opts, "link=".Encode(ReadLink($path)));
	}
	if ($fi->type eq 'FILE') {
	    if ($fieldsref->{CKSUM}) {
		push(@opts, "cksum=".Cksum($path));
	    }
	    if ($fieldsref->{MD5}) {
		push(@opts, "md5=".Encode(MD5($path)));
	    }
	}

	my $attrs = join(' ',
		$fi->type,
		$fi->size,
		$fi->mtime,
		$fi->perm,
		$user,
		$group,
		@opts);
	push(@lines, (Encode($relpath).' '.$attrs));
	push(@{$dirlines{$dirpath}}, (Encode($basename).' '.$attrs));
    }

    my $wd = cwd();
    chdir($dir) or die "can't chdir to $dir: $!\n";
    finddepth({wanted =>\&TocEntry}, '.');
    chdir($wd) or die "can't chdir to $wd: $!\n";

    # Write master in reverse order to convert depth-first search to
    # breadth-first (so that directories precede their children).
    WriteFile("$dir.toc", join("\n", $header, reverse(@lines)));
}

# Load single directory table-of-contents into file info cache.

sub LoadDirTOC($) {
    my ($url) = @_;
    my $toc = geturl("$url/.cftoc");

    my $fi = GetFileInfo($url);
    $fi->dir([]) if ($fi);
    LoadTOC($url, $toc, 0);
}

# Load directory tree table-of-contents into file info cache.

sub LoadTreeTOC($) {
    my ($url) = @_;

    my $toc = geturl("$url.toc");
    LoadTOC($url, $toc, 1);
}

sub LoadTOC($$$) {
    my ($url, $toc, $recursive) = @_;

    # !!! Check signature?

    die "unknown directory format for $url\n"
	    unless $toc =~ /^# cftoc 1.0/;

    # Load directory into file info cache

    my $count = 0;
    foreach my $line (split("\n", $toc)) {
	next if $line =~ /^#/;
	next if $line =~ /^\s*$/;
	my ($epath, $type, $size, $mtime, $perm, $user, $group, @opts)
		= split(' ', $line);

	my $path = Decode($epath);

	# Concatenate path with url, but get rid of any "." in the middle.
	my $fullpath;
	if ($path eq '.') {
	    $fullpath = $url;
	} elsif ($path =~ m{^\./}) {
	    $fullpath = $url . substr($path, 1);
	} else {
	    $fullpath = "$url/$path";
	}

	my $fi = new FileInfo;
	$fi->type($type);
	$fi->size($size);
	$fi->mtime($mtime);
	$fi->perm($perm);

	my @ufields = getpwnam($user);
	$fi->uid($ufields[2]) if (@ufields);
	my @gfields = getgrnam($group);
	$fi->gid($gfields[2]) if (@gfields);

	if ($recursive && $type eq 'DIR') {
	    $fi->dir([]);
	}

	# Add optional file attributes that we understand.
	foreach my $opt (@opts) {
	    my ($key, $val) = split('=', $opt, 2);
	    if ($key eq 'link') {
		$fi->linkdest(Decode($val));
	    } elsif ($key eq 'cksum') {
		$fi->cksum($val);
	    } elsif ($key eq 'md5') {
		$fi->md5($val);
	    }
	}

	$file_info{$fullpath} = $fi;
	Debug("added TOC entry for $fullpath");
	$count++;

	# Append this item to the parent's directory listing.
	my $dir = dirname($fullpath);
	if (defined $file_info{$dir}) {
            # Parent directory is in cache - append this item to the
            # parent's directory listing.
            push(@{$file_info{$dir}->dir}, basename($path));
        }
    }
    Debug("loaded toc for $url, $count entries");
}

# Remove matching files.

sub Tidy ($%) {
    my ($path, %opts) = @_;

    Debug("tidying $path");

    my $fi = GetFileInfo($path);
    my $newpath = $path;
    if ($fi->type eq 'LINK' && $opts{FOLLOW_LINKS}) {
	$newpath = FollowLinks($path);
	$fi = GetFileInfo($newpath);
    }
    my $ftype = $fi->type;
    return if ($ftype eq 'NONE');

    my $excluded = 0;
    if ($opts{EXCLUDE}) {
	# If explicitly excluded skip this path and any children - if simply
	# doesn't match any pattern then exclude this path from tidy but
	# consider children.
	$excluded = IsExcluded($opts{EXCLUDE}, $path, 2);
	return if $excluded == 1;
    }

    unless ($excluded
	    || $opts{ATIME} && Age($fi->atime) < $opts{ATIME}
	    || $opts{CTIME} && Age($fi->ctime) < $opts{CTIME}
	    || $opts{MTIME} && Age($fi->mtime) < $opts{MTIME}
	    ) {
	# File matches criteria
	if ($ftype ne 'DIR' || $opts{RMDIR}) {
	    # File is not a directory, or directory removal is allowed.
	    RemoveFile($path, %opts);
	    return;
	}
    }

    if ($ftype eq 'DIR') {
	# Check children.
	if ( $opts{'RECURSE'} ) {
	    $opts{'RECURSE'}--;
	    foreach my $file ( ReadDir($path) ) {
		Tidy("$path/$file", %opts);
	    }
	}
    }
}

# Make sure file contains specified line - replacing any lines that matches
# specified pattern.

sub SetLine($$$%) {
    my ($path, $pattern, $line, %opts) = @_;

    die "desired line ($line) does not match pattern ($pattern)\n"
	    unless $line =~ $pattern;

    # Make sure pattern will match an entire line - so we can use it to
    # substitute in the new line
    $pattern .= '.*' unless (substr($pattern, -1, 1) eq '$');
    $pattern = ".*$pattern" unless (substr($pattern, 0, 1) eq '^');

    Debug("check that $path has $line (pattern=$pattern)");

    my $orig = ReadFile($path);
    my $new = $orig;
    my $subs = ($new =~ s/$pattern/$line/mg);
    if ($subs == 0) {
	$new .= "\n" . $line;
	MarkChange("adding $line to $path");
    } elsif ($subs == 1) {
	return if ($new eq $orig);
	MarkChange("changing $pattern to $line in $path");
    } else {
	die "setline failed: $subs lines matched $pattern in $path\n";
    }
    WriteFile($path, $new, %opts);
}

sub setline {
    my ($optref, $path, $pattern, $line) = get_options(\%parse_opt, @_);
    SetLine($path, $pattern, $line, %{$optref});
}
push(@EXPORT, '&setline');

# Delete lines that match a specified pattern.

sub DeleteLines($$$%) {
    my ($path, $pattern, $line, %opts) = @_;

    Debug("comment lines in $path matching ($pattern)");

    my $orig = ReadFile($path);
    my @origlines = split("\n", $orig);
    my @newlines = grep(!/$pattern/, @origlines);
    my $new = join("\n", @newlines);

    my $delcount = @origlines - @newlines;
    if ($delcount) {
	MarkChange(
	    "deleting $delcount line(s) from $path that match $pattern");
    }
    WriteFile($path, $new, %opts);
}

sub deletelines {
    my ($optref, $path, $pattern, $line) = get_options(\%parse_opt, @_);
    DeleteLines($path, $pattern, $line, %{$optref});
}
push(@EXPORT, '&deletelines');

# Synchronize to catalogued network volume

sub RemoteSync($$%) {
    my ($srcpath, $destpath, %opts) = @_;

    eval { LoadTreeTOC($srcpath); };
    LoadDirTOC(dirname($srcpath)) if ($@);

    FileSync($srcpath, $destpath, %opts, REMOTE_SRC=>1);
}

# Make $destpath have the same contents as $srcpath.

sub FileSync {
    my ($srcpath, $destpath, %opts) = @_;

    Debug("syncing $srcpath to $destpath");
    my $si = GetFileInfo($srcpath);
    if ($opts{EXCLUDE} && IsExcluded($opts{EXCLUDE}, $srcpath)) {
	if ($opts{PURGE} eq 'EXCLUDED') {
	    $si->type('NONE');
	} else {
	    return
	}
    }
    my $newsrcpath = $srcpath;
    if ($si->type eq 'LINK' && $opts{FOLLOW_LINKS}) {
	$newsrcpath = FollowLinks($srcpath);
	$si = GetFileInfo($newsrcpath);
    }

    my $srctype = $si->type;
    my $di = GetFileInfo($destpath);
    my $desttype = $di->type;

    # !!! do I really want to enforce absolute paths?
#    IsAbsolute($srcpath) or die "file path is not absolute: $srcpath";
#    IsAbsolute($destpath) or die "file path is not absolute: $destpath";

    die "syncing onto self: $srcpath and $destpath\n"
	    if (defined $di->dev
		&& $si->dev == $di->dev
		&& $si->ino == $di->ino);

    if ($srctype eq 'NONE') {
	# Source does not exist
	if ($desttype ne 'NONE') {
	    # Destination does exist - are we allowed to delete it?

	    if ($opts{'PURGE'}) {
		RemoveFile($destpath, %opts);
	    } elsif (! $opts{SKIP_MISSING}) {
		die "source does not exist: $srcpath\n";
	    }
	}
	return;
    } elsif ( !$opts{CHANGE_TYPES}
	    && ($desttype ne 'NONE')
	    && ($srctype ne $desttype)
	    ) {
	die "type mismatch, $srcpath is $srctype and $destpath is $desttype";
    }


    # Make sure parent directories of $destpath exist

    my $parent = dirname($destpath);
    MakeDir($parent);

    if ($srctype eq 'LINK') {
	my $target = ReadLink($srcpath) or die $!;
	MakeLink($target, $destpath);

	# No need to set permissions on link - or is there!?
	return
    } elsif ($srctype eq 'DIR') {
	MakeDir($destpath, %opts, MODE=>undef);
	if ( $opts{'RECURSE'} ) {
	    $opts{'RECURSE'}--;
	    DirSync($srcpath, $destpath, %opts);
	}
    } elsif ($srctype eq 'FILE') {
	CopyFile($newsrcpath, $destpath, %opts);
    } else {
	die "file type $srctype not supported: $srcpath";
    }

}

# Change user and set environment appropriately - analogous to running
# "su user".

sub BecomeUser($) {
    my ($user) = @_;

    my @ufields;
    if ( $user =~ /^[0-9]+$/ ) {
	@ufields = getpwuid($user) or die "user $user unknown";
    } else {
	@ufields = getpwnam($user) or die "user $user unknown";
    }
    my ($login, $pass, $uid, $gid, $quota, $comment, $gcos, $home, $shell)
	    = @ufields;

    # Determine all group memberships of user (to add all valid group rights
    # like the C library initgroups(3) does)
    #
    # Initialize list with two entries for default group of user - that way if
    # user has no other group member ships all root's effective group
    # memberships will be removed.

    my @groups = ($gid, $gid);
    setgrent();
    while( my ($gname, $gpasswd, $gid2, $members) = getgrent() ) {
	foreach my $member (split(' ', $members)) {
	    if ($member eq $user) {
		push(@groups, $gid2);
		last;
	    }
	}
    }

    # Set real, effective, and supplementary group access list to the
    # appropriate groups for nguser.

    ($(, $)) = ($gid, join(' ', @groups));

    # Change real and effective user ID.
    # Perl is showing its true obscure syntax here.

    ($<, $>) = ($uid, $uid);

    # Initialize environment.

    $ENV{'HOME'} = $home;
    $ENV{'LOGNAME'} = $user;
}

# Run command as specified user. Throws exception if command fails.

sub RunAsUser($@) {
    my ($user, @args) = @_;
    my $cmd = join(' ', @args);

    my $msg = "running";
    $msg += "as $user" if length($user);
    MarkChange("$msg: $cmd");

    return unless ($update);

    PreSpawn();
    my $pid = fork();
    if (! defined $pid) {
	die "can't fork: $!";
    }
    if ($pid) {
	# This is the parent - wait for child.

	waitpid($pid, 0);
	die "run failed ($?): $cmd\n" if $?;
    } else {
	# This is the child.

	BecomeUser($user) if length($user);
	exec(@args) or die $!;
    }
}

# Run specified command and throw error if it fails (returns non-zero status
# code). This is for commands with side effects - it won't actually be run
# if we are in no update mode.

sub Run(@) {
    my $cmd = join(' ', @_);

    MarkChange("running: $cmd");
    return unless ($update);

    PreSpawn();
    my $pid = open3(*INPIPE, *PIPE, '', $cmd);
    while (my $line = <PIPE>) {
	chomp($line);
	Info($line) if ($line =~ /\S/);
    }
    close(PIPE) or die $!;
    close(INPIPE) or die $!;
    waitpid($pid, 0);
    die "run failed ($?): $cmd\n" if $?;
}

# Run command and return the output. Throw error if it fails. This command
# should not have any side effects as it WILL be run in no-update mode.

sub ReadCommand($) {
    my ($command) = @_;
    my $buffer = '';
    my $maxsize = 100000;
    open(PIPE, "$command |") or die "command failed $!: $command\n";
    read(PIPE, $buffer, $maxsize);
    close(PIPE) or die "command failed $!: $command\n";
    return $buffer;
}
sub read_command {
    ReadCommand(join(' ', @_));
}
push(@EXPORT, '&read_command');

# Get short hostname of this machines.
# Eventually allow sites to includes some domain components in this host
# name? (so that site could have multiple domains and hosts are only unique
# within a domain)

my $short_host;
sub GetHost() {
    if (! defined $short_host) {
	require Sys::Hostname;
	$short_host = Sys::Hostname::hostname();
	$short_host =~ s/\..*//;
    }
    return $short_host;
}

# Determine base of configuration script/module tree

sub GetBase() {
    return $cfbase;
}

# Get path to session state files. Create new session if one does not exist
# yet.

sub GetSession() {
    return $ENV{CF_SESSION} if (defined $ENV{CF_SESSION});

    # Get path for new session - will need something better than naming by
    # process id if we want to keep info around for historical info...
    my $sid = $PID;
    my $session = "$vardir/session/$sid";
    my $host = GetHost();

    Undo("debug", "starting session $sid");

    $ENV{CF_SESSION} = $session;
    SetSession();

    RealMakeDir($session);

    # Initialize session state.
    my $changes = $change_count || 0;
    RealWriteFile($change_file, $changes);

    # !!! this script needs to be thought out more carefully!
    # what exactly are it's duties:
    # *
    RealWriteFile("$session/init.sh", <<EOF );
CF_SESSION=$session; export CF_SESSION
cf_svcdir=`dirname \$0`
case \$cf_svcdir in
/*) : ;;
*) cf_svcdir="`pwd`/\$cf_svcdir"
esac
cf_host='$host'
if [ -f \$cf_svcdir/site.ini ]
then
    . \$cf_svcdir/site.ini
fi
if [ -f \$cf_svcdir/PERHOST/\$cf_host/host.ini ]
then
    . \$cf_svcdir/PERHOST/\$cf_host/host.ini
fi
EOF

    return $session;
}

# Define session-based globals

sub SetSession() {
    my $session = $ENV{CF_SESSION};
    $change_file = "$session/changes";
}

SetSession() if (defined $ENV{CF_SESSION});

# Clean up (flush) various things before spawning a child cf process.
sub PreSpawn() {
    # Flush log
    if (defined $logfh) {
	close($logfh) or die $!;
	$logfh = undef;
    }

    # Flush file checksums.
    UntieFile(%cksums) if tied %cksums;

    # Flush change count.
    # Only need to do this if we have an external change file and more than
    # one change has been made since the last sync with the change file
    # (first change is flushed immediately).
    if (defined $change_file && $change_count > $last_read_changes+1) {
	RealWriteFile($change_file, $change_count);
	undef $change_count;
    }
}


#----------

sub file {
    my ($optref, @files) = get_options(\%parse_opt, @_);
    foreach my $path (@files) {
	if (-e $path) {
	    CheckFile($path, %{$optref});
	} else {
	    TouchFile($path, %{$optref}) unless $optref->{SKIP_MISSING};
	}
    }
}
push(@EXPORT, '&file');

sub fix {
    my ($optref, @paths) = get_options(\%parse_opt, @_);
    foreach my $path (@paths) {
	CheckFile($path, %{$optref});
    }
}
push(@EXPORT, '&fix');

sub copy {
    my ($optref, $src, $dest) = get_options(\%parse_opt, @_);
    FileSync($src, $dest, %{$optref});
}
push(@EXPORT, '&copy');

sub rcopy {
    my ($optref, $src, $dest) = get_options(\%parse_opt, @_);
    RemoteSync($src, $dest, %{$optref});
}
push(@EXPORT, '&rcopy');

sub toc {
    my ($optref, $dir) = get_options(\%parse_opt, @_);
    my %fields = ();

    if ($optref->{TOC_FIELDS}) {
	foreach my $field (@{ $optref->{TOC_FIELDS} }) {
	    $fields{$field} = 1;
	}
    }
    MakeTOC($dir, \%fields);
}
push(@EXPORT, '&toc');

sub directory {
    my ($optref, @paths) = get_options(\%parse_opt, @_);
    foreach my $path (@paths) {
	MakeDir($path, %{$optref});
    }
}
push(@EXPORT, '&directory');

# !!! I hate the name "makelink" = but link is a perl builtin
sub makelink {
    my ($optref, $src, $dest) = get_options(\%parse_opt, @_);
    MakeLink($src, $dest, %{$optref});
}
push(@EXPORT, '&makelink');

sub tidy {
    my ($optref, @paths) = get_options(\%parse_opt, @_);
    foreach my $path (@paths) {
	Tidy($path, %{$optref});
    }
}
push(@EXPORT, '&tidy');

sub run {
    my ($optref, @args) = get_options(\%parse_opt, @_);
    RunAsUser($optref->{OWNER}, @args);
}
push(@EXPORT, '&run');

sub writefile {
    my ($optref, $path, $content) = get_options(\%parse_opt, @_);
    WriteFile($path, $content, %{$optref});
}
push(@EXPORT, '&writefile');

sub initshell {
    get_options({}, @_);
    return GetSession()."/init.sh";
}
push(@EXPORT, '&initshell');
string_op('initshell');

sub error {
    my ($optref, @args) = get_options({}, @_);
    Error(@args)
}
push(@EXPORT, '&error');

sub debug {
    my ($optref, @args) = get_options({}, @_);
    Debug(@args)
}
push(@EXPORT, '&debug');

sub markchange {
    my ($optref, @args) = get_options({}, @_);
    MarkChange(@args)
}
push(@EXPORT, '&markchange');

sub gettemp {
    my ($optref, @args) = get_options({}, @_);
    return TempName(@args[0]);
}
push(@EXPORT, '&gettemp');
string_op('gettemp');

sub movetemp {
    my ($optref, $tmp) = get_options(\%parse_opt, @_);
    my $target = $tmp;
    $target =~ s/-cfnew//;
    MarkChange("updating $target");
    return unless updating();
    MoveTemp($tmp, $target ,%{$optref});
}
push(@EXPORT, '&movetemp');

sub disable {
    my ($optref, $path) = get_options(\%parse_opt, @_);
    my $rotate = $optref->{ROTATE};

    if (!defined $rotate) {
	# Just remove the path
	Tidy($path, %{$optref}, RECURSE=>1, RMDIR=>1);
	return;
    }

    my $fi = GetFileInfo($path);
    if ($fi->type ne 'NONE') {
	$optref->{OWNER} = $fi->uid unless defined $optref->{OWNER};
	$optref->{GROUP} = $fi->gid unless defined $optref->{GROUP};
	$optref->{MODE} = $fi->perm unless defined $optref->{MODE};
    }

    MarkChange("rotating $path");
    for (my $i = $rotate; $i > 0; $i--) {
	my $backpath = "$path.$i";
	my $prior = ($i == 1) ? $path : ("$path." . ($i-1));
	if (-d $backpath && ! -l $backpath) {
	    die "can't replace directory $backpath with $path\n";
	}
	if (-e $prior && $update) {
	    rename($prior, $backpath)
		    or die "can't move $prior to $backpath: $!\n";
	}
    }
    WriteFile($path, "", %{$optref});
}
push(@EXPORT, '&disable');

sub purge {
    get_options({}, @_);
    PurgeBackupIndex();
    PurgeCksum();
}
push(@EXPORT, '&purge');

#--------
# Initialize environment

# Determine base of configuration script/module tree
if (not defined $cfbase) {
    # Locate configuration library.

    # First look for library (modules) parallel to this script
    $cfbase = dirname(AbsolutePath($scriptdir));
    if (! -f "$cfbase/relnum") {
	# No library parallel to script - use the default location
	$cfbase = "/var/lib/cf/inputs";
    }
    $ENV{CF_BASEDIR} = $cfbase ;

    # get mode settings from config-file
    my $flagfile = "$vardir/cf-flags";
    if ( -f $flagfile ) {
	SetFlagsFromHash(LoadVars($flagfile));
    }
}

# Get mode settings from environment.
SetFlags(split(':', $ENV{CF_FLAGS}));

# Module Cleanup

END { }

#----------------------------------------------------------------------
package Cf::Module;

sub require() {
    my $self = shift;
    $self->configure() unless -f $self->get_config_flag();
}

sub get_config_flag() {
    my $self = shift;
    my $session = Cf::GetSession();
    return "$session/configured/".$self->{name};
}

sub set_configured() {
    my $self = shift;
    Cf::RealWriteFile($self->get_config_flag(), "");
}

# Fall back to invoking call() method.
use vars qw($AUTOLOAD);
sub AUTOLOAD {
    my $self = shift();
    my $method = $AUTOLOAD;
    $method =~ s/.*://;   # strip fully-qualified portion
    $self->call($method, @_);
}

#----------------------------------------------------------------------
{
package Cf::ScriptModule;

use vars qw(@ISA);
@ISA = qw(Cf::Module);

# Simple config module that invokes a script for each method.

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = { name => shift, script => shift };
    bless($self, $class);
    return $self;
}

sub DESTROY {}

# Invoke method by name
sub call {
    my $self = shift;
    my $function = shift;
    Cf::PreSpawn();
    system($self->{script}, $function, @_) == 0
	    or die $self->{name}.":$function failed\n";
}

sub configure() {
    my $self = shift;
    $self->call("configure");
    $self->set_configured();
}
}

#----------------------------------------------------------------------
{
package Cf::ModuleWrap;

use vars qw(@ISA);
@ISA = qw(Cf::Module);

# Simple config module that invokes a script for each method.

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = { name => shift, package => shift };
    bless($self, $class);
    return $self;
}

sub DESTROY {}

# Invoke method by name
sub call {
    my $self = shift;
    my $package = $self->{package};
    my $function = shift;
    my $result = eval sprintf('%s::%s(@_);', $package, $function);
    die $@ if $@;
    return $result;
}

sub configure() {
    my $self = shift;
    $self->call("configure");
    $self->set_configured();
}
}

#----------------------------------------------------------------------
package main;

import Cf;
use File::Basename;

# Precautionary permission mask.
# !!! shouldn't I let user set this?
umask(022);

sub usage(;$$) {
    my ($exitcode, $message) = @_;
    $exitcode = 1 unless defined $exitcode;

    print STDERR $message, "\n" if defined $message;
    print STDERR "cf [options] command [command-options] [arg ..]\n";
    print STDERR "  run 'cf man' for detailed help\n";
    exit($exitcode);
}


# Command names that can only be used on the command line (because the name
# is illegal/reserved in perl)
my %cmd_alias = (
    'init-shell' => 'initshell',
    'write' => 'writefile',
    'link' => 'makelink',
    'require' => 'requiremodule',
    'directories' => 'directory',
);

sub main() {
    my ($cmd, @args) = Cf::parse_args(@ARGV);
    usage(0) if (!defined $cmd);

    # perform command

    $cmd = $cmd_alias{$cmd} if defined $cmd_alias{$cmd};
    my $rv;
    if ($cmd eq 'man') {
	# Generate manual page/extended help
	# autogenerat this instead of using pod?
	require Pod::Usage;
	Pod::Usage::pod2usage(-exitstatus => 0, -verbose => 2)
    } elsif ($cmd =~ /^[a-z]*$/) {
	# Built-in command
	$rv = eval "Cf::$cmd(\@args)";
	die "$@\n" if $@;
    } elsif ($cmd =~ /^(\w*):(.*)/) {
	# Invoke another configuration module
	my $module = $1;
	my $function = $2;

	$rv = Cf::CallModule($module, $function, @args);
    } else {
	usage(1, "$0: bad command: $cmd");
    }

    my $result_type = Cf::OpResult($cmd);
    if (defined $result_type) {
	exit ($rv ? 0 : 1) if $result_type eq 'boolean';
	print $rv;
    }
}

# Process command line - unless being run by regression test script.
unless ($main::Testing) {
    main();
    exit(0);
}

1;

__END__

=head1 NAME

sample - Using cf

=head1 SYNOPSIS

cf [I<options>] I<cf-command> [I<comand-options>] [I<arg> ..]

 Options:
    --debug, -d			Display debugging messages
    --inform, -I		Display any changes made
    --dry-run, --test, -n	Just pretend to make changes
    --splay=minutes		Random delay at start
    --help			Display this page

 Commands:
   copy src dest		Copy src file(s) to dest
   directory dir ..		Create directory(s)
   file path ..			Create file or fix attributes
   fix path ..			Fix file attributes
   link src dest		Link dest to src
   man				Display manual page
   module:function arg ..
   require module ..
   run cmd arg ..		Execute external command
   rcopy src dest		Copy files from network volume to dest
   setline path pat line	Make sure file contains line
   toc dir			Generate table-of-contents for directory
   write file content		Write specified data to file

 Command Options:
    --changetype
    --checktype
    --group group
    --mode permission
    --purge
    --recurse depth
    --skipmissing
    --user user


=cut
