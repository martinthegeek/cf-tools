#!/usr/bin/env perl

use strict;
use English;
use Getopt::Long;
use Pod::Usage;
use File::Basename;

my %simple_cmds = (
    'man' => sub { pod2usage(-exitstatus => 0, -verbose => 2) },
    'init-shell' => sub { print dirname($0)."/cfinit.sh" },
);
my %commands = (
    'changes' => \&do_changes,
    'copy' => \&do_copy,
    'directory' => \&do_directory,
    'directories' => \&do_directory,
    'file' => \&do_file,
    'fix' => \&do_fix,
    'link' => \&do_link,
    'run' => \&do_run,
);

# Parse command line.

my $cmd = shift(@ARGV);
if (defined $commands{$cmd}) {
    # core script command - continue on
} elsif (defined $commands{$cmd}) {
    # simple command - do it now
    $simple_cmds{$cmd}->();
    exit();
} elsif ($cmd =~ /^(\w*):(.*)/) {
    # Invoke another configuration module
    my $module = $1;
    my $function = $2;
    my $cfbase = $ENV{CF_BASEDIR} || dirname($0)."/..";
    exec("$cfbase/$module/configure", $function, @ARGV) or die $!;
} else {
    pod2usage("$0: bad command: $cmd") unless defined $commands{$cmd};
}

my $help = 0;
my %opts = ();		# Options for config operation
my %flags = ();		# Major Cf modal flags
my $checktype;
Getopt::Long::Configure("require_order");
GetOptions(
	'user|owner|u=s' => \$opts{OWNER},
	'group|g=s' => \$opts{GROUP},
	'mode|m=s' => \$opts{MODE},
	'changetype|t' => \$opts{CHANGE_TYPES},
	'recurse|r=i' => \$opts{RECURSE},

	'checktype!' => \$checktype,

	'inform|I!' => \$flags{INFORM},
	'dry-run|recon|test|n!' => \$flags{DRYRUN},
	'debug|d!' => \$flags{DEBUG},

	'help|?' => \$help,
	) or pod2usage(2);
pod2usage(1) if $help;

$opts{CHANGE_TYPES} = !$checktype if defined $checktype;
if ( $opts{MODE} =~ /^[1-9]/ ) {
    # Make sure file mode numbers are interpreted in octal
    $opts{MODE} = "0$opts{MODE}";
}

# Remove undefined options (GetOptions initiazes all keys to undef)
foreach my $key (keys(%opts)) {
    if (!defined($opts{$key})) { delete $opts{$key} };
}

# Load the config module now.

require Config::Cf;

# Set mode flags

my @flaglist = ();
foreach my $key (keys(%flags)) {
    if (defined($flags{$key})) {
	$key = "!$key" if ($flags{$key} == 0);
	push(@flaglist, $key);
    }
}
Config::Cf::SetFlags(@flaglist);

# Invoke command

$commands{$cmd}->();
exit(0);


sub get_session() {
    return $ENV{CF_SESSION} if (defined $ENV{CF_SESSION});
    my $cfvar = ($UID == 0) ? '/var/lib/cf' : "$ENV{HOME}/.cf";
    my $session = "$cfvar/session/$PID";
    WriteFile("$session/changes", "0");
    return $session;
}

sub do_changes() {
    pod2usage("wrong number of arguments (need 1 or less)") if (@ARGV > 1);
    my $initial = (@ARGV == 1) ? $ARGV[0] : 0;

    my $session = get_session();
    my $changes = ReadFile("$session/changes");
    print $changes-$initial, "\n";
}

sub do_file() {
    foreach my $path (@ARGV) {
	if (-e $path) {
	    Config::Cf::CheckFile($path, %opts);
	} else {
	    Config::Cf::TouchFile($path, %opts);
	}
    }
}

sub do_fix() {
    foreach my $path (@ARGV) {
	Config::Cf::CheckFile($path, %opts);
    }
}

sub do_copy() {
    pod2usage("wrong number of arguments (need 2)") if (@ARGV != 2);
    Config::Cf::FileSync(@ARGV, %opts);
}

sub do_directory() {
    foreach my $path (@ARGV) {
	Config::Cf::MakeDir($path, %opts);
    }
}

sub do_link() {
    pod2usage("wrong number of arguments (need 2)") if (@ARGV != 2);
    Config::Cf::MakeLink(@ARGV, %opts);
}

sub do_run() {
    Config::Cf::Run(@ARGV);
}

__END__

=head1 NAME

sample - Using cf

=head1 SYNOPSIS

cf I<cf-command> [I<options>] [I<arg> ..]

 Commands:
   copy src .. dest	Copy src file(s) to dest
   directory dir ..	Create directory(s)
   file path ..		Create file or fix attributes
   fix path ..		Fix file attributes
   link src dest	Link dest to src
   man			Display manual page
   run cmd arg ..	Execute external command

 Options:
    --user user
    --mode permission
    --group group
    --changetype
    --recurse

=cut
